Apollo Cyber 运行时框架(\-Apollo Cyber R\-T Framework) 是基于组件概念来构建的. 每个组件都是\-Cyber框架的一个构建块, 它包括一个特定的算法模块， 此算法模块处理一组输入数椐并产生一组输出数椐。

要创建并启动一个算法组件, 需要通过以下4个步骤\-:


\begin{DoxyItemize}
\item 初如化组件的文件结构
\item 实现组件类
\item 设置配置文件
\item 启动组件
\end{DoxyItemize}

下面的例子展示了如何创建，编译，运行一个组件，并观察组件在屏幕上的输出。 如果想更深入的探索\-Apollo Cyber R\-T框架, 可以在这个目录{\ttfamily /apollo/cyber/examples/}找到很多例子，这些例子详细展示了如何使用\-Cyber框架的各种功能。

{\itshape Note\-: 这些例子必须运行在\-Apollo docker环境， 且需要通过\-Bazel来编译.}

\subsection*{初始化组件文件结构}

例如组件的根目录为{\ttfamily /apollo/cyber/examples/common\-\_\-component\-\_\-example/}需要创建以下文件\-:


\begin{DoxyItemize}
\item Header file\-: \hyperlink{common__component__example_8h}{common\-\_\-component\-\_\-example.\-h}
\item Source file\-: common\-\_\-component\-\_\-example.\-cc
\item Build file\-: B\-U\-I\-L\-D
\item D\-A\-G dependency file\-: common.\-dag
\item Launch file\-: common.\-launch
\end{DoxyItemize}

\subsection*{实现组件类}

\subsubsection*{实现组件头文件}

如何实现{\ttfamily \hyperlink{common__component__example_8h}{common\-\_\-component\-\_\-example.\-h}}\-:


\begin{DoxyItemize}
\item 继承 Component 类
\item 定义自己的 {\ttfamily Init} 和 {\ttfamily Proc} 函数. Proc 需要指定输入数椐类型。
\item 使用{\ttfamily C\-Y\-B\-E\-R\-\_\-\-R\-E\-G\-I\-S\-T\-E\-R\-\_\-\-C\-O\-M\-P\-O\-N\-E\-N\-T}宏定义把组件类注册成全局可用。
\end{DoxyItemize}

```cpp \#include $<$memory$>$ \#include \char`\"{}cyber/class\-\_\-loader/class\-\_\-loader.\-h\char`\"{} \#include \char`\"{}cyber/component/component.\-h\char`\"{} \#include \char`\"{}cyber/examples/proto/examples.\-pb.\-h\char`\"{}

using apollo\-::cyber\-::examples\-::proto\-::\-Driver; using \hyperlink{classapollo_1_1cyber_1_1Component}{apollo\-::cyber\-::\-Component}; using \hyperlink{classapollo_1_1cyber_1_1ComponentBase}{apollo\-::cyber\-::\-Component\-Base};

class \hyperlink{classCommonComponentSample}{Common\-Component\-Sample} \-: public \hyperlink{classapollo_1_1cyber_1_1Component}{Component$<$\-Driver, Driver$>$} \{ public\-: bool \hyperlink{namespaceapollo_1_1cyber_a2d055a81b338116634deaf8ac3367aca}{Init()} override; bool Proc(const std\-::shared\-\_\-ptr$<$\-Driver$>$\& msg0, const std\-::shared\-\_\-ptr$<$\-Driver$>$\& msg1) override; \};

\hyperlink{component_8h_a031103527dc7f59a627459d635de10f8}{C\-Y\-B\-E\-R\-\_\-\-R\-E\-G\-I\-S\-T\-E\-R\-\_\-\-C\-O\-M\-P\-O\-N\-E\-N\-T(\-Common\-Component\-Sample)} ```

\subsubsection*{实现组件源文件}

对于源文件 {\ttfamily common\-\_\-component\-\_\-example.\-cc}, {\ttfamily Init} 和 {\ttfamily Proc} 这两个函数需要实现.

```cpp \#include \char`\"{}cyber/examples/common\-\_\-component\-\_\-example/common\-\_\-component\-\_\-example.\-h\char`\"{} \#include \char`\"{}cyber/class\-\_\-loader/class\-\_\-loader.\-h\char`\"{} \#include \char`\"{}cyber/component/component.\-h\char`\"{}

bool \hyperlink{classCommonComponentSample_ae2a3f8c8ce4b9cfd9c6b357628bc84ee}{Common\-Component\-Sample\-::\-Init()} \{ A\-I\-N\-F\-O $<$$<$ \char`\"{}\-Commontest component init\char`\"{}; return true; \}

bool \hyperlink{classCommonComponentSample_ab84ea2f74b8ab92a74733b392319ea5e}{Common\-Component\-Sample\-::\-Proc}(const std\-::shared\-\_\-ptr$<$\-Driver$>$\& msg0, const std\-::shared\-\_\-ptr$<$\-Driver$>$\& msg1) \{ A\-I\-N\-F\-O $<$$<$ \char`\"{}\-Start common component Proc \mbox{[}\char`\"{} $<$$<$ msg0-\/$>$msg\-\_\-id() $<$$<$ \char`\"{}\mbox{]} \mbox{[}\char`\"{} $<$$<$ msg1-\/$>$msg\-\_\-id() $<$$<$ \char`\"{}\mbox{]}\char`\"{}; return true; \} ```

\subsubsection*{创建\-B\-U\-I\-L\-D编译文件}

创建 bazel B\-U\-I\-L\-D 文件.

```bash load(\char`\"{}//tools\-:cpplint.\-bzl\char`\"{}, \char`\"{}cpplint\char`\"{})

package(default\-\_\-visibility = \mbox{[}\char`\"{}//visibility\-:public\char`\"{}\mbox{]})

cc\-\_\-binary( name = \char`\"{}libcommon\-\_\-component\-\_\-example.\-so\char`\"{}, deps = \mbox{[}\char`\"{}\-:common\-\_\-component\-\_\-example\-\_\-lib\char`\"{}\mbox{]}, linkopts = \mbox{[}\char`\"{}-\/shared\char`\"{}\mbox{]}, linkstatic = False, )

cc\-\_\-library( name = \char`\"{}common\-\_\-component\-\_\-example\-\_\-lib\char`\"{}, srcs = \mbox{[} \char`\"{}common\-\_\-component\-\_\-example.\-cc\char`\"{}, \mbox{]}, hdrs = \mbox{[} \char`\"{}common\-\_\-component\-\_\-example.\-h\char`\"{}, \mbox{]}, deps = \mbox{[} \char`\"{}//cyber\char`\"{}, \char`\"{}//cyber/examples/proto\-:examples\-\_\-cc\-\_\-proto\char`\"{}, \mbox{]}, )

cpplint() ``` \subsection*{设置配置文件}

\subsubsection*{配置\-D\-A\-G依赖文件}

在\-D\-A\-G依赖配置文件 (例如common.\-dag)中配置下面的项\-:


\begin{DoxyItemize}
\item Channel names\-: 输入输出数椐的\-Channel名字
\item Library path\-: 此组件最终编译出的库的名字
\item Class name\-: 此组件的入口类的名字
\end{DoxyItemize}

```bash \section*{Define all coms in D\-A\-G streaming.}

component\-\_\-config \{ component\-\_\-library \-: \char`\"{}/apollo/bazel-\/bin/cyber/examples/common\-\_\-component\-\_\-example/libcommon\-\_\-component\-\_\-example.\-so\char`\"{} components \{ class\-\_\-name \-: \char`\"{}\-Common\-Component\-Sample\char`\"{} config \{ name \-: \char`\"{}common\char`\"{} readers \{ channel\-: \char`\"{}/apollo/prediction\char`\"{} \} readers \{ channel\-: \char`\"{}/apollo/test\char`\"{} \} \} \} \} ```

\subsubsection*{配置launch启动文件}

在launch启动文件中(common.\-launch), 配置下面的项\-:


\begin{DoxyItemize}
\item 组件的名字
\item 上一步创建的dag配置的名字。
\item 组件运行时所在的进程目录。
\end{DoxyItemize}

```bash $<$cyber$>$ $<$component$>$ $<$name$>$common$<$/name$>$ $<$dag\-\_\-conf$>$/apollo/cyber/examples/common\-\_\-component\-\_\-example/common.dag$<$/dag\-\_\-conf$>$ $<$process\-\_\-name$>$common$<$/process\-\_\-name$>$ $<$/component$>$ $<$/cyber$>$ ```

\subsection*{启动这个组件}

通过下面的命令来编译组件\-:

```bash bash /apollo/apollo.sh build ```

Note\-: 确定组件正常编译成功

然后配置环境\-:

```bash cd /apollo/cyber source setup.\-bash ```

有两种方法来启动组件\-:


\begin{DoxyItemize}
\item 使用launch文件来启动 (推荐这种方式)
\end{DoxyItemize}

```bash cyber\-\_\-launch start /apollo/cyber/examples/common\-\_\-component\-\_\-example/common.launch ```


\begin{DoxyItemize}
\item 使用dag文件来启动
\end{DoxyItemize}

```bash mainboard -\/d /apollo/cyber/examples/common\-\_\-component\-\_\-example/common.dag ``` 