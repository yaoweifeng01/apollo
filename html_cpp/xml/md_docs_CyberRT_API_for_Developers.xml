<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.6">
  <compounddef id="md_docs_CyberRT_API_for_Developers" kind="page">
    <compoundname>md_docs_CyberRT_API_for_Developers</compoundname>
    <title>Cyber RT API for Developers</title>
    <detaileddescription>
<para>Construct a new ParameterService object</para><para>This document provides an extensive technical deep dive into how to create, manipulate and use Cyber RT&apos;s API.</para><para><heading level="2">Table of Contents</heading>
</para><para><itemizedlist>
<listitem><para><ulink url="#Talker-Listener">Talker-Listener</ulink></para></listitem><listitem><para><ulink url="#Service-Creation-and-Use">Service Creation and Use</ulink></para></listitem><listitem><para><ulink url="#Param-parameter-service">Param parameter service</ulink></para></listitem><listitem><para><ulink url="#LOG-API">Log API</ulink></para></listitem><listitem><para><ulink url="#Building-a-module-based-on-Component">Building a module based on Component</ulink></para></listitem><listitem><para><ulink url="#Launch">Launch</ulink></para></listitem><listitem><para><ulink url="#timer">Timer</ulink></para></listitem><listitem><para><ulink url="#use-of-time">Time API</ulink></para></listitem><listitem><para><ulink url="#Record-file-Read-and-Write">Record file: Read and Write</ulink></para></listitem><listitem><para><ulink url="##API-Directory">C++ API Directory</ulink><itemizedlist>
<listitem><para><ulink url="#node-api">Node</ulink></para></listitem><listitem><para><ulink url="#writer-api">Writer</ulink></para></listitem><listitem><para><ulink url="#client-api">Client</ulink></para></listitem><listitem><para><ulink url="#parameter-api">Parameter</ulink></para></listitem><listitem><para><ulink url="#timer-api">Timer</ulink></para></listitem><listitem><para><ulink url="#timer-api">Time</ulink></para></listitem><listitem><para><ulink url="#duration-api">Duration</ulink></para></listitem><listitem><para><ulink url="#rate-api">Rate</ulink></para></listitem><listitem><para><ulink url="#recordreader-api">RecordReader</ulink></para></listitem><listitem><para><ulink url="#recordwriter-api">RecordWriter</ulink></para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para><para><heading level="2">Talker-Listener</heading>
</para><para>The first part of demonstrating CyberRT API is to understand the Talker/Listener example. Following are three essential concepts: node (basic unit), reader(facility to read message) and writer(facility to write message) of the example.</para><para><heading level="3">Create a node</heading>
</para><para>In the CyberRT framework, the node is the most fundamental unit, similar to the role of a <computeroutput>handle</computeroutput>. When creating a specific functional object (writer, reader, etc.), you need to create it based on an existing node instance. The node creation interface is as follows:</para><para>```C std::unique_ptr&lt;Node&gt; <ref refid="namespaceapollo_1_1cyber_1ae369c5de0279f2a5745d0438d532bc89" kindref="member">apollo::cyber::CreateNode</ref>(const std::string&amp; node_name, const std::string&amp; name_space = &quot;&quot;); ```</para><para><itemizedlist>
<listitem><para>Parameters:<itemizedlist>
<listitem><para>node_name: name of the node, globally unique identifier</para></listitem><listitem><para>name_space: name of the space where the node is located ``` name_space is empty by default. It is the name of the space concatenated with node_name. The format is /namespace/node_name ```</para></listitem></itemizedlist>
</para></listitem><listitem><para>Return value - An exclusive smart pointer to Node</para></listitem><listitem><para>Error Conditions - when <computeroutput><ref refid="namespaceapollo_1_1cyber_1a2d055a81b338116634deaf8ac3367aca" kindref="member">cyber::Init()</ref></computeroutput> has not called, the system is in an uninitialized state, unable to create a node, return nullptr</para></listitem></itemizedlist>
</para><para><heading level="3">Create a writer</heading>
</para><para>The writer is the basic facility used in CyberRT to send messages. Every writer corresponds to a channel with a specific data type. The writer is created by the <computeroutput>CreateWriter</computeroutput> interface in the node class. The interfaces are listed as below:</para><para>```C template &lt;typename messaget&gt;=&quot;&quot;&gt; auto CreateWriter(const std::string&amp; channel_name) -&gt; std::shared_ptr&lt;Writer&lt;MessageT&gt;&gt;; template &lt;typename messaget&gt;=&quot;&quot;&gt; auto CreateWriter(const proto::RoleAttributes&amp; role_attr) -&gt; std::shared_ptr&lt;Writer&lt;MessageT&gt;&gt;;</para><para>```<itemizedlist>
<listitem><para>Parameters:<itemizedlist>
<listitem><para>channel_name: the name of the channel to write to</para></listitem><listitem><para>MessageT: The type of message to be written out</para></listitem></itemizedlist>
</para></listitem><listitem><para>Return value - Shared pointer to the Writer object</para></listitem></itemizedlist>
</para><para><heading level="3">Create a reader</heading>
</para><para>The reader is the basic facility used in cyber to receive messages. Reader has to be bound to a callback function when it is created. When a new message arrives in the channel, the callback will be called. The reader is created by the <computeroutput>CreateReader</computeroutput> interface of the node class. The interfaces are listed as below:</para><para>```C template &lt;typename messaget&gt;=&quot;&quot;&gt; auto CreateReader(const std::string&amp; channel_name, const std::function&lt;void(const std::shared_ptr&lt;MessageT&gt;&amp;)&gt;&amp; reader_func) -&gt; std::shared_ptr&lt;Reader&lt;MessageT&gt;&gt;;</para><para>template &lt;typename messaget&gt;=&quot;&quot;&gt; auto CreateReader(const ReaderConfig&amp; config, const CallbackFunc&lt;MessageT&gt;&amp; reader_func = nullptr) -&gt; std::shared_ptr&lt;cyber::Reader&lt;MessageT&gt;&gt;;</para><para>template &lt;typename messaget&gt;=&quot;&quot;&gt; auto CreateReader(const proto::RoleAttributes&amp; role_attr, const CallbackFunc&lt;MessageT&gt;&amp; reader_func = nullptr) -&gt; std::shared_ptr&lt;cyber::Reader&lt;MessageT&gt;&gt;; ```<itemizedlist>
<listitem><para>Parameters:<itemizedlist>
<listitem><para>MessageT: The type of message to read</para></listitem><listitem><para>channel_name: the name of the channel to receive from</para></listitem><listitem><para>reader_func: callback function to process the messages</para></listitem></itemizedlist>
</para></listitem><listitem><para>Return value - Shared pointer to the Reader object</para></listitem></itemizedlist>
</para><para><heading level="3">Code Example</heading>
</para><para><heading level="4">Talker (cyber/examples/talker.cc)</heading>
</para><para>```C #include &quot;cyber/cyber.h&quot; #include &quot;cyber/proto/chatter.pb.h&quot; #include &quot;cyber/time/rate.h&quot; #include &quot;cyber/time/time.h&quot; using <ref refid="classapollo_1_1cyber_1_1Rate" kindref="compound">apollo::cyber::Rate</ref>; using <ref refid="classapollo_1_1cyber_1_1Time" kindref="compound">apollo::cyber::Time</ref>; using apollo::cyber::proto::Chatter; int main(int argc, char *argv[]) { // init cyber framework apollo::cyber::Init(argv[0]); // create talker node std::shared_ptr&lt;apollo::cyber::Node&gt; talker_node( <ref refid="namespaceapollo_1_1cyber_1ae369c5de0279f2a5745d0438d532bc89" kindref="member">apollo::cyber::CreateNode</ref>(&quot;talker&quot;)); // create talker auto talker = talker_node-&gt;CreateWriter&lt;Chatter&gt;(&quot;channel/chatter&quot;); Rate rate(1.0); while (<ref refid="namespaceapollo_1_1cyber_1aafa5f9962b51918897897bbc0fdd802f" kindref="member">apollo::cyber::OK()</ref>) { static uint64_t seq = 0; auto msg = std::make_shared&lt;apollo::cyber::proto::Chatter&gt;(); msg-&gt;set_timestamp(Time::Now().ToNanosecond()); msg-&gt;set_lidar_timestamp(Time::Now().ToNanosecond()); msg-&gt;set_seq(seq++); msg-&gt;set_content(&quot;Hello, apollo!&quot;); talker-&gt;Write(msg); AINFO &lt;&lt; &quot;talker sent a message!&quot;; rate.Sleep(); } return 0; } ```</para><para><heading level="4">Listener (cyber/examples/listener.cc)</heading>
</para><para>```C #include &quot;cyber/cyber.h&quot; #include &quot;cyber/proto/chatter.pb.h&quot; void MessageCallback( const std::shared_ptr&lt;apollo::cyber::proto::Chatter&gt;&amp; msg) { AINFO &lt;&lt; &quot;Received message seq-&gt; &quot; &lt;&lt; msg-&gt;seq(); AINFO &lt;&lt; &quot;msgcontent-&gt;&quot; &lt;&lt; msg-&gt;content(); } int main(int argc, char *argv[]) { // init cyber framework apollo::cyber::Init(argv[0]); // create listener node auto listener_node = <ref refid="namespaceapollo_1_1cyber_1ae369c5de0279f2a5745d0438d532bc89" kindref="member">apollo::cyber::CreateNode</ref>(&quot;listener&quot;); // create listener auto listener = listener_node-&gt;CreateReader&lt;apollo::cyber::proto::Chatter&gt;( &quot;channel/chatter&quot;, MessageCallback); <ref refid="namespaceapollo_1_1cyber_1a7929114e78a9c595b0ee715968ca2712" kindref="member">apollo::cyber::WaitForShutdown()</ref>; return 0; } ``` <heading level="4">Bazel BUILD file(cyber/samples/BUILD)</heading>
</para><para>```bazel cc_binary( name = &quot;talker&quot;, srcs = [ &quot;talker.cc&quot;, ], deps = [ &quot;//cyber&quot;, &quot;//cyber/examples/proto:examples_cc_proto&quot;, ], )</para><para>cc_binary( name = &quot;listener&quot;, srcs = [ &quot;listener.cc&quot;, ], deps = [ &quot;//cyber&quot;, &quot;//cyber/examples/proto:examples_cc_proto&quot;, ], ) ``` <heading level="4">Build and Run</heading>
</para><para><itemizedlist>
<listitem><para>Build: bazel build cyber/examples/â€¦</para></listitem><listitem><para>Run talker/listener in different terminals:<itemizedlist>
<listitem><para>./bazel-bin/cyber/examples/talker</para></listitem><listitem><para>./bazel-bin/cyber/examples/listener</para></listitem></itemizedlist>
</para></listitem><listitem><para>Examine the results: you should see message printing out on listener.</para></listitem></itemizedlist>
</para><para><heading level="2">Service Creation and Use</heading>
</para><para><heading level="3">Introduction</heading>
</para><para>In an autonomous driving system, there are many scenarios that require more from module communication than just sending or receiving messages. Service is another way of communication between nodes. Unlike channel, service implements <computeroutput>two-way</computeroutput> communication, e.g. a node obtains a response by sending a request. This section introduces the <computeroutput>service</computeroutput> module in CyberRT API with examples.</para><para><heading level="3">Demo - Example</heading>
</para><para>Problem: create a client-server model that pass Driver.proto back and forth. When a request is sent in by the client, the server parses/processes the request and returns the response.</para><para>The implementation of the demo mainly includes the following steps.</para><para><heading level="4">Define request and response messages</heading>
</para><para>All messages in cyber are in the <computeroutput>protobuf</computeroutput> format. Any protobuf message with serialize/deserialize interfaces can be used as the service request and response message. <computeroutput>Driver</computeroutput> in examples.proto is used as service request and response in this example:</para><para>```protobuf // filename: examples.proto syntax = &quot;proto2&quot;; package apollo.cyber.examples.proto; message Driver { optional string content = 1; optional uint64 msg_id = 2; optional uint64 timestamp = 3; }; ``` <heading level="4">Create a service and a client</heading>
</para><para>```c // filename: cyber/examples/service.cc #include &quot;cyber/cyber.h&quot; #include &quot;cyber/examples/proto/examples.pb.h&quot;</para><para>using apollo::cyber::examples::proto::Driver;</para><para>int main(int argc, char* argv[]) { apollo::cyber::Init(argv[0]); std::shared_ptr&lt;apollo::cyber::Node&gt; node( <ref refid="namespaceapollo_1_1cyber_1ae369c5de0279f2a5745d0438d532bc89" kindref="member">apollo::cyber::CreateNode</ref>(&quot;start_node&quot;)); auto server = node-&gt;CreateService&lt;Driver, Driver&gt;( &quot;test_server&quot;, [](const std::shared_ptr&lt;Driver&gt;&amp; request, std::shared_ptr&lt;Driver&gt;&amp; response) { AINFO &lt;&lt; &quot;server: I am driver server&quot;; static uint64_t id = 0; ++id; response-&gt;set_msg_id(id); response-&gt;set_timestamp(0); }); auto client = node-&gt;CreateClient&lt;Driver, Driver&gt;(&quot;test_server&quot;); auto driver_msg = std::make_shared&lt;Driver&gt;(); driver_msg-&gt;set_msg_id(0); driver_msg-&gt;set_timestamp(0); while (<ref refid="namespaceapollo_1_1cyber_1aafa5f9962b51918897897bbc0fdd802f" kindref="member">apollo::cyber::OK()</ref>) { auto res = client-&gt;SendRequest(driver_msg); if (res != nullptr) { AINFO &lt;&lt; &quot;client: responese: &quot; &lt;&lt; res-&gt;ShortDebugString(); } else { AINFO &lt;&lt; &quot;client: service may not ready.&quot;; } sleep(1); }</para><para><ref refid="namespaceapollo_1_1cyber_1a7929114e78a9c595b0ee715968ca2712" kindref="member">apollo::cyber::WaitForShutdown()</ref>; return 0; } ``` <heading level="4">Bazel build file</heading>
</para><para>```bazel cc_binary( name = &quot;service&quot;, srcs = [ &quot;service.cc&quot;, ], deps = [ &quot;//cyber&quot;, &quot;//cyber/examples/proto:examples_cc_proto&quot;, ], ) ```</para><para><heading level="4">Build and run</heading>
</para><para><itemizedlist>
<listitem><para>Build service/client: bazel build cyber/examples/â€¦</para></listitem><listitem><para>Run: ./bazel-bin/cyber/examples/service</para></listitem><listitem><para>Examining result: you should see content below in apollo/data/log/service.INFO</para></listitem></itemizedlist>
</para><para>``` I1124 16:36:44.568845 14965 service.cc:30] [service] server: i am driver server I1124 16:36:44.569031 14949 service.cc:43] [service] client: responese: msg_id: 1 timestamp: 0 I1124 16:36:45.569514 14966 service.cc:30] [service] server: i am driver server I1124 16:36:45.569932 14949 service.cc:43] [service] client: responese: msg_id: 2 timestamp: 0 I1124 16:36:46.570627 14967 service.cc:30] [service] server: i am driver server I1124 16:36:46.571024 14949 service.cc:43] [service] client: responese: msg_id: 3 timestamp: 0 I1124 16:36:47.571566 14968 service.cc:30] [service] server: i am driver server I1124 16:36:47.571962 14949 service.cc:43] [service] client: responese: msg_id: 4 timestamp: 0 I1124 16:36:48.572634 14969 service.cc:30] [service] server: i am driver server I1124 16:36:48.573030 14949 service.cc:43] [service] client: responese: msg_id: 5 timestamp: 0 ```</para><para><heading level="3">Precautions</heading>
</para><para><itemizedlist>
<listitem><para>When registering a service, note that duplicate service names are not allowed</para></listitem><listitem><para>The node name applied when registering the server and client should not be duplicated either</para></listitem></itemizedlist>
</para><para><heading level="2">Parameter Service</heading>
</para><para>The Parameter Service is used for shared data between nodes, and provides basic operations such as <computeroutput>set</computeroutput>, <computeroutput>get</computeroutput>, and <computeroutput>list</computeroutput>. The Parameter Service is based on the <computeroutput>Service</computeroutput> implementation and contains service and client.</para><para><heading level="3">Parameter Object</heading>
</para><para><heading level="4">Supported Data types</heading>
</para><para>All parameters passed through cyber are <computeroutput><ref refid="classapollo_1_1cyber_1_1Parameter" kindref="compound">apollo::cyber::Parameter</ref></computeroutput> objects, the table below lists the 5 supported parameter types.</para><para><table rows="7" cols="3"><row>
<entry thead="yes"><para>Parameter type </para></entry><entry thead="yes"><para>C++ data type </para></entry><entry thead="yes"><para>protobuf data type  </para></entry></row>
<row>
<entry thead="no"><para>apollo::cyber::proto::ParamType::INT </para></entry><entry thead="no"><para>int64_t </para></entry><entry thead="no"><para>int64 </para></entry></row>
<row>
<entry thead="no"><para>apollo::cyber::proto::ParamType::DOUBLE </para></entry><entry thead="no"><para>double </para></entry><entry thead="no"><para>double </para></entry></row>
<row>
<entry thead="no"><para>apollo::cyber::proto::ParamType::BOOL </para></entry><entry thead="no"><para>bool </para></entry><entry thead="no"><para>bool </para></entry></row>
<row>
<entry thead="no"><para>apollo::cyber::proto::ParamType::STRING </para></entry><entry thead="no"><para>std::string </para></entry><entry thead="no"><para>string </para></entry></row>
<row>
<entry thead="no"><para>apollo::cyber::proto::ParamType::PROTOBUF </para></entry><entry thead="no"><para>std::string </para></entry><entry thead="no"><para>string </para></entry></row>
<row>
<entry thead="no"><para>apollo::cyber::proto::ParamType::NOT_SET </para></entry><entry thead="no"><para>- </para></entry><entry thead="no"><para>- </para></entry></row>
</table>
</para><para>Besides the 5 types above, Parameter also supports interface with protobuf object as incoming parameter. Post performing serialization processes the object and converts it to the STRING type for transfer.</para><para><heading level="4">Creating the Parameter Object</heading>
</para><para>Supported constructors:</para><para>```C Parameter(); // Name is empty, type is NOT_SET explicit Parameter(const Parameter&amp; parameter); explicit Parameter(const std::string&amp; name); // typeä¸ºNOT_SET Parameter(const std::string&amp; name, const bool bool_value); Parameter(const std::string&amp; name, const int int_value); Parameter(const std::string&amp; name, const int64_t int_value); Parameter(const std::string&amp; name, const float double_value); Parameter(const std::string&amp; name, const double double_value); Parameter(const std::string&amp; name, const std::string&amp; string_value); Parameter(const std::string&amp; name, const char* string_value); Parameter(const std::string&amp; name, const std::string&amp; msg_str, const std::string&amp; full_name, const std::string&amp; proto_desc); Parameter(const std::string&amp; name, const google::protobuf::Message&amp; msg); ``` Sample code of using Parameter object:</para><para>```C Parameter a(&quot;int&quot;, 10); Parameter b(&quot;bool&quot;, true); Parameter c(&quot;double&quot;, 0.1); Parameter d(&quot;string&quot;, &quot;cyber&quot;); Parameter e(&quot;string&quot;, std::string(&quot;cyber&quot;)); // proto message Chatter Chatter chatter; Parameter f(&quot;chatter&quot;, chatter); std::string msg_str(&quot;&quot;); chatter.SerializeToString(&amp;msg_str); std::string msg_desc(&quot;&quot;); ProtobufFactory::GetDescriptorString(chatter, &amp;msg_desc); Parameter g(&quot;chatter&quot;, msg_str, Chatter::descriptor()-&gt;full_name(), msg_desc); ```</para><para><heading level="4">Interface and Data Reading</heading>
</para><para>Interface list:</para><para>```C inline ParamType type() const; inline std::string TypeName() const; inline std::string Descriptor() const; inline const std::string Name() const; inline bool AsBool() const; inline int64_t AsInt64() const; inline double AsDouble() const; inline const std::string AsString() const; std::string DebugString() const; template &lt;typename type&gt;=&quot;&quot;&gt; typename std::enable_if&lt;std::is_base_of&lt;google::protobuf::Message, Type&gt;::value, Type&gt;::type value() const; template &lt;typename type&gt;=&quot;&quot;&gt; typename std::enable_if&lt;std::is_integral&lt;Type&gt;::value &amp;&amp; !std::is_same&lt;Type, bool&gt;::value, Type&gt;::type value() const; template &lt;typename type&gt;=&quot;&quot;&gt; typename std::enable_if&lt;std::is_floating_point&lt;Type&gt;::value, Type&gt;::type value() const; template &lt;typename type&gt;=&quot;&quot;&gt; typename std::enable_if&lt;std::is_convertible&lt;Type, std::string&gt;::value, const std::string&amp;&gt;::type value() const; template &lt;typename type&gt;=&quot;&quot;&gt; typename std::enable_if&lt;std::is_same&lt;Type, bool&gt;::value, bool&gt;::type value() const; ```</para><para>An example of how to use those interfaces:</para><para>```C Parameter a(&quot;int&quot;, 10); a.Name(); // return int a.Type(); // return apollo::cyber::proto::ParamType::INT a.TypeName(); // return string: INT a.DebugString(); // return string: {name: &quot;int&quot;, type: &quot;INT&quot;, value: 10} int x = a.AsInt64(); // x = 10 x = <ref refid="namespaceapollo_1_1cyber_1_1base_1aa3e2fff9b18a1214af4a70546fb7120f" kindref="member">a.value&lt;int64_t&gt;()</ref>; // x = 10 x = a.AsString(); // Undefined behavior, error log prompt f.TypeName(); // return string: chatter auto chatter = <ref refid="namespaceapollo_1_1cyber_1_1base_1aa3e2fff9b18a1214af4a70546fb7120f" kindref="member">f.value&lt;Chatter&gt;()</ref>; ```</para><para><heading level="3">Parameter Service</heading>
</para><para>If a node wants to provide a Parameter Service to other nodes, then you need to create a <computeroutput>ParameterService</computeroutput>.</para><para>```C /**<itemizedlist>
<listitem><para>*</para></listitem><listitem><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>node</parametername>
</parameternamelist>
<parameterdescription>
<para>shared_ptr of the node handler</para></parameterdescription>
</parameteritem>
</parameterlist>
explicit ParameterService(const std::shared_ptr&lt;Node&gt;&amp; node); ```</para></listitem></itemizedlist>
</para><para>Since all parameters are stored in the parameter service object, the parameters can be manipulated directly in the ParameterService without sending a service request.</para><para><bold>Setting parameters:</bold></para><para>```C /**<itemizedlist>
<listitem><para>Set the Parameter object</para></listitem><listitem></listitem><listitem><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>parameter</parametername>
</parameternamelist>
<parameterdescription>
<para>parameter to be set</para></parameterdescription>
</parameteritem>
</parameterlist>
void SetParameter(const Parameter&amp; parameter); ``` <bold>Getting parameters:</bold></para></listitem></itemizedlist>
</para><para>```C /**<itemizedlist>
<listitem><para>Get the Parameter object</para></listitem><listitem></listitem><listitem><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>param_name</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
</para></listitem><listitem><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>parameter</parametername>
</parameternamelist>
<parameterdescription>
<para>the pointer to store</para></parameterdescription>
</parameteritem>
</parameterlist>
</para></listitem><listitem><para><simplesect kind="return"><para>true</para></simplesect>
</para></listitem><listitem><para><simplesect kind="return"><para>false call service fail or timeout</para></simplesect>
bool GetParameter(const std::string&amp; param_name, Parameter* parameter); ```</para></listitem></itemizedlist>
</para><para><bold>Getting the list of parameters:</bold></para><para>```C /**<itemizedlist>
<listitem><para>Get all the Parameter objects</para></listitem><listitem></listitem><listitem><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>parameters</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer of vector to store all the parameters</para></parameterdescription>
</parameteritem>
</parameterlist>
</para></listitem><listitem><para><simplesect kind="return"><para>true</para></simplesect>
</para></listitem><listitem><para><simplesect kind="return"><para>false call service fail or timeout</para></simplesect>
bool ListParameters(std::vector&lt;Parameter&gt;* parameters); ```</para></listitem></itemizedlist>
</para><para><heading level="3">Parameter Client</heading>
</para><para>If a node wants to use parameter services of other nodes, you need to create a <computeroutput>ParameterClient</computeroutput>.</para><para>```C /**<itemizedlist>
<listitem><para>Construct a new ParameterClient object</para></listitem><listitem></listitem><listitem><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>node</parametername>
</parameternamelist>
<parameterdescription>
<para>shared_ptr of the node handler</para></parameterdescription>
</parameteritem>
</parameterlist>
</para></listitem><listitem><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>service_node_name</parametername>
</parameternamelist>
<parameterdescription>
<para>node name which provide a param services</para></parameterdescription>
</parameteritem>
</parameterlist>
ParameterClient(const std::shared_ptr&lt;Node&gt;&amp; node, const std::string&amp; service_node_name); ```</para></listitem></itemizedlist>
</para><para>You could also perform <computeroutput>SetParameter</computeroutput>, <computeroutput>GetParameter</computeroutput> and <computeroutput>ListParameters</computeroutput> mentioned under <ulink url="#Parameter-Service">Parameter Service</ulink>.</para><para><heading level="3">Demo - example</heading>
</para><para>```C #include &quot;cyber/cyber.h&quot; #include &quot;cyber/parameter/parameter_client.h&quot; #include &quot;cyber/parameter/parameter_server.h&quot;</para><para>using <ref refid="classapollo_1_1cyber_1_1Parameter" kindref="compound">apollo::cyber::Parameter</ref>; using <ref refid="classapollo_1_1cyber_1_1ParameterServer" kindref="compound">apollo::cyber::ParameterServer</ref>; using <ref refid="classapollo_1_1cyber_1_1ParameterClient" kindref="compound">apollo::cyber::ParameterClient</ref>;</para><para>int main(int argc, char** argv) { apollo::cyber::Init(*argv); std::shared_ptr&lt;apollo::cyber::Node&gt; node = <ref refid="namespaceapollo_1_1cyber_1ae369c5de0279f2a5745d0438d532bc89" kindref="member">apollo::cyber::CreateNode</ref>(&quot;parameter&quot;); auto param_server = std::make_shared&lt;ParameterServer&gt;(node); auto param_client = std::make_shared&lt;ParameterClient&gt;(node, &quot;parameter&quot;); param_server-&gt;SetParameter(Parameter(&quot;int&quot;, 1)); Parameter parameter; param_server-&gt;GetParameter(&quot;int&quot;, &amp;parameter); AINFO &lt;&lt; &quot;int: &quot; &lt;&lt; parameter.AsInt64(); param_client-&gt;SetParameter(Parameter(&quot;string&quot;, &quot;test&quot;)); param_client-&gt;GetParameter(&quot;string&quot;, &amp;parameter); AINFO &lt;&lt; &quot;string: &quot; &lt;&lt; parameter.AsString(); param_client-&gt;GetParameter(&quot;int&quot;, &amp;parameter); AINFO &lt;&lt; &quot;int: &quot; &lt;&lt; parameter.AsInt64(); return 0; } ``` <heading level="4">Build and run</heading>
</para><para><itemizedlist>
<listitem><para>Build: bazel build cyber/examples/â€¦</para></listitem><listitem><para>Run: ./bazel-bin/cyber/examples/paramserver</para></listitem></itemizedlist>
</para><para><heading level="2">Log API</heading>
</para><para><heading level="3">Log library</heading>
</para><para>Cyber log library is built on top of glog. The following header files need to be included:</para><para>```C #include &quot;cyber/common/log.h&quot; #include &quot;cyber/init.h&quot; ```</para><para><heading level="3">Log configuration</heading>
</para><para>Default global config path: cyber/setup.bash</para><para>The configs below could be modified by devloper:</para><para>``` export GLOG_log_dir=/apollo/data/log export GLOG_alsologtostderr=0 export GLOG_colorlogtostderr=1 export GLOG_minloglevel=0 ```</para><para><heading level="3">Log initialization</heading>
</para><para>Call the Init method at the code entry to initialize the log:</para><para>```c++ apollo::cyber::cyber::Init(argv[0]) is initialized. If no macro definition is made in the previous component, the corresponding log is printed to the binary log. ```</para><para><heading level="3">Log output macro</heading>
</para><para>Log library is encapsulated in Log printing macros. The related log macros are used as follows:</para><para>```C ADEBUG &lt;&lt; &quot;hello cyber.&quot;; AINFO &lt;&lt; &quot;hello cyber.&quot;; AWARN &lt;&lt; &quot;hello cyber.&quot;; AERROR &lt;&lt; &quot;hello cyber.&quot;; AFATAL &lt;&lt; &quot;hello cyber.&quot;;</para><para>```</para><para><heading level="3">Log format</heading>
</para><para>The format is <computeroutput>&lt;MODULE_NAME&gt;.log.&lt;LOG_LEVEL&gt;.&lt;datetime&gt;.&lt;process_id&gt;</computeroutput></para><para><heading level="3">About log files</heading>
</para><para>Currently, the only different output behavior from default glog is that different log levels of a module will be written into the same log file.</para><para><heading level="2">Building a module based on Component</heading>
</para><para><heading level="3">Key concepts</heading>
</para><para><heading level="4">1. Component</heading>
</para><para>The component is the base class that Cyber-RT provides to build application modules. Each specific application module can inherit the Component class and define its own <computeroutput>Init</computeroutput> and <computeroutput>Proc</computeroutput> functions so that it can be loaded into the Cyber framework.</para><para><heading level="4">2. Binary vs Component</heading>
</para><para>There are two options to use Cyber-RT framework for applications:</para><para><itemizedlist>
<listitem><para>Binary based: the application is compiled separately into a binary, which communicates with other cyber modules by creating its own <computeroutput>Reader</computeroutput> and <computeroutput>Writer</computeroutput>.</para></listitem><listitem><para>Component based: the application is compiled into a Shared Library. By inheriting the Component class and writing the corresponding dag description file, the Cyber-RT framework will load and run the application dynamically.</para></listitem></itemizedlist>
</para><para><heading level="5">The essential Component interface</heading>
</para><para><itemizedlist>
<listitem><para>The component&apos;s <computeroutput><ref refid="namespaceapollo_1_1cyber_1a2d055a81b338116634deaf8ac3367aca" kindref="member">Init()</ref></computeroutput> function is like the main function that does some initialization of the algorithm.</para></listitem><listitem><para>Component&apos;s <computeroutput>Proc()</computeroutput> function works like Reader&apos;s callback function that is called by the framework when a message arrives.</para></listitem></itemizedlist>
</para><para><heading level="5">Advantages of using Component</heading>
</para><para><itemizedlist>
<listitem><para>Component can be loaded into different processes through the launch file, and the deployment is flexible.</para></listitem><listitem><para>Component can change the received channel name by modifying the dag file without recompiling.</para></listitem><listitem><para>Component supports receiving multiple types of data.</para></listitem><listitem><para>Component supports providing multiple fusion strategies.</para></listitem></itemizedlist>
</para><para><heading level="4">3. Dag file format</heading>
</para><para>An example dag file:</para><para>``` <heading level="1">Define all coms in DAG streaming.</heading>
</para><para>module_config { module_library : &quot;lib/libperception_component.so&quot; components { class_name : &quot;PerceptionComponent&quot; config { name : &quot;perception&quot; readers { channel: &quot;perception/channel_name&quot; } } } timer_components { class_name : &quot;DriverComponent&quot; config { name : &quot;driver&quot; interval : 100 } } } ``<computeroutput><itemizedlist>
<listitem><para>**module_library**: If you want to load the .so library the root directory is the working directory of cyber (the same directory ofsetup.bash`)</para></listitem><listitem><para><bold>components &amp; timer_component</bold>: Select the base component class type that needs to be loaded.</para></listitem><listitem><para><bold>class_name</bold>: the name of the component class to load</para></listitem><listitem><para><bold>name</bold>: the loaded class_name as the identifier of the loading example</para></listitem><listitem><para><bold>readers</bold>: Data received by the current component, supporting 1-3 channels of data.</para></listitem></itemizedlist>
</computeroutput></para><para><computeroutput><heading level="3">Demo - examples</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput><heading level="4">Common_component_example(cyber/examples/common_component_example/*)</heading>
</computeroutput></para><para><computeroutput> Header definition(<ref refid="common__component__example_8h" kindref="compound">common_component_example.h</ref>)</computeroutput></para><para><computeroutput>```C #include &lt;memory&gt;</computeroutput></para><para><computeroutput>#include &quot;cyber/class_loader/class_loader.h&quot; #include &quot;cyber/component/component.h&quot; #include &quot;cyber/examples/proto/examples.pb.h&quot;</computeroutput></para><para><computeroutput>using apollo::cyber::examples::proto::Driver; using <ref refid="classapollo_1_1cyber_1_1Component" kindref="compound">apollo::cyber::Component</ref>; using <ref refid="classapollo_1_1cyber_1_1ComponentBase" kindref="compound">apollo::cyber::ComponentBase</ref>;</computeroutput></para><para><computeroutput>class Commontestcomponent : public <ref refid="classapollo_1_1cyber_1_1Component" kindref="compound">Component&lt;Driver, Driver&gt;</ref> { public: bool <ref refid="namespaceapollo_1_1cyber_1a2d055a81b338116634deaf8ac3367aca" kindref="member">Init()</ref> override; bool Proc(const std::shared_ptr&lt;Driver&gt;&amp; msg0, const std::shared_ptr&lt;Driver&gt;&amp; msg1) override; }; <ref refid="component_8h_1a031103527dc7f59a627459d635de10f8" kindref="member">CYBER_REGISTER_COMPONENT(Commontestcomponent)</ref> ```</computeroutput></para><para><computeroutput>Cpp file implementation(common_component_example.cc)</computeroutput></para><para><computeroutput>```C #include &quot;cyber/examples/common_component_smaple/common_component_example.h&quot;</computeroutput></para><para><computeroutput>#include &quot;cyber/class_loader/class_loader.h&quot; #include &quot;cyber/component/component.h&quot;</computeroutput></para><para><computeroutput>bool <ref refid="namespaceapollo_1_1cyber_1a2d055a81b338116634deaf8ac3367aca" kindref="member">Commontestcomponent::Init()</ref> { AINFO &lt;&lt; &quot;Commontest component init&quot;; return true; }</computeroutput></para><para><computeroutput>bool Commontestcomponent::Proc(const std::shared_ptr&lt;Driver&gt;&amp; msg0, const std::shared_ptr&lt;Driver&gt;&amp; msg1) { AINFO &lt;&lt; &quot;Start commontest component Proc [&quot; &lt;&lt; msg0-&gt;msg_id() &lt;&lt; &quot;] [&quot; &lt;&lt; msg1-&gt;msg_id() &lt;&lt; &quot;]&quot;; return true; } ```</computeroutput></para><para><computeroutput><heading level="4">Timer_component_example(cyber/examples/timer_component_example/*)</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>Header definition(<ref refid="timer__component__example_8h" kindref="compound">timer_component_example.h</ref>)</computeroutput></para><para><computeroutput>```C #include &lt;memory&gt;</computeroutput></para><para><computeroutput>#include &quot;cyber/class_loader/class_loader.h&quot; #include &quot;cyber/component/component.h&quot; #include &quot;cyber/component/timer_component.h&quot; #include &quot;cyber/examples/proto/examples.pb.h&quot;</computeroutput></para><para><computeroutput>using apollo::cyber::examples::proto::Driver; using <ref refid="classapollo_1_1cyber_1_1Component" kindref="compound">apollo::cyber::Component</ref>; using <ref refid="classapollo_1_1cyber_1_1ComponentBase" kindref="compound">apollo::cyber::ComponentBase</ref>; using <ref refid="classapollo_1_1cyber_1_1TimerComponent" kindref="compound">apollo::cyber::TimerComponent</ref>; using <ref refid="classapollo_1_1cyber_1_1Writer" kindref="compound">apollo::cyber::Writer</ref>;</computeroutput></para><para><computeroutput>class TimertestComponent : public TimerComponent { public: bool <ref refid="namespaceapollo_1_1cyber_1a2d055a81b338116634deaf8ac3367aca" kindref="member">Init()</ref> override; bool Proc() override;</computeroutput></para><para><computeroutput> private: std::shared_ptr&lt;Writer&lt;Driver&gt;&gt; driver_writer_ = nullptr; }; <ref refid="component_8h_1a031103527dc7f59a627459d635de10f8" kindref="member">CYBER_REGISTER_COMPONENT(TimertestComponent)</ref> ``` Cpp file implementation(timer_component_example.cc)</computeroutput></para><para><computeroutput>```C #include &quot;cyber/examples/timer_component_example/timer_component_example.h&quot;</computeroutput></para><para><computeroutput>#include &quot;cyber/class_loader/class_loader.h&quot; #include &quot;cyber/component/component.h&quot; #include &quot;cyber/examples/proto/examples.pb.h&quot;</computeroutput></para><para><computeroutput>bool <ref refid="namespaceapollo_1_1cyber_1a2d055a81b338116634deaf8ac3367aca" kindref="member">TimertestComponent::Init()</ref> { driver_writer_ = node_-&gt;CreateWriter&lt;Driver&gt;(&quot;/carstatus/channel&quot;); return true; }</computeroutput></para><para><computeroutput>bool TimertestComponent::Proc() { static int i = 0; auto out_msg = std::make_shared&lt;Driver&gt;(); out_msg-&gt;set_msg_id(i++); driver_writer_-&gt;Write(out_msg); AINFO &lt;&lt; &quot;timertestcomponent: Write drivermsg-&gt;&quot; &lt;&lt; out_msg-&gt;ShortDebugString(); return true; } ``` <heading level="4">Build and run</heading>
</computeroutput></para><para><computeroutput> Use timertestcomponent as example:</computeroutput></para><para><computeroutput><itemizedlist>
<listitem><para>Build: bazel build cyber/examples/timer_component_smaple/â€¦</para></listitem><listitem><para>Run: mainboard -d cyber/examples/timer_component_smaple/timer.dag</para></listitem></itemizedlist>
</computeroutput></para><para><computeroutput><heading level="3">Precautions</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput><itemizedlist>
<listitem><para>Component needs to be registered to load the class through SharedLibrary. The registration interface looks like:</para></listitem></itemizedlist>
</computeroutput></para><para><computeroutput>```C CYBER_REGISTER_CLASS(DriverComponent) ```</computeroutput></para><para><computeroutput>If you use a namespace when registering, you also need to add a namespace when you define it in the dag file.</computeroutput></para><para><computeroutput><itemizedlist>
<listitem><para>The configuration files of the Component and TimerComponent are different, please be careful not to mix the two up.</para></listitem></itemizedlist>
</computeroutput></para><para><computeroutput><heading level="2">Launch</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput><bold>cyber_launch</bold> is the launcher of the Cyber-RT framework. It starts multiple mainboards according to the launch file, and loads different components into different mainboards according to the dag file. cyber_launch supports two scenarios for dynamically loading components or starting Binary programs in a child process.</computeroutput></para><para><computeroutput><heading level="3">Launch File Format</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>``` &lt;cyber&gt; &lt;module&gt; &lt;name&gt;driver&lt;/name&gt; &lt;dag_conf&gt;driver.dag&lt;/dag_conf&gt; &lt;process_name&gt;&lt;/process_name&gt; &lt;exception_handler&gt;exit&lt;/exception_handler&gt; &lt;/module&gt; &lt;module&gt; &lt;name&gt;perception&lt;/name&gt; &lt;dag_conf&gt;perception.dag&lt;/dag_conf&gt; &lt;process_name&gt;&lt;/process_name&gt; &lt;exception_handler&gt;respawn&lt;/exception_handler&gt; &lt;/module&gt; &lt;module&gt; &lt;name&gt;planning&lt;/name&gt; &lt;dag_conf&gt;planning.dag&lt;/dag_conf&gt; &lt;process_name&gt;&lt;/process_name&gt; &lt;/module&gt; &lt;/cyber&gt; ```</computeroutput></para><para><computeroutput><bold>Module</bold>: Each loaded component or binary is a module</computeroutput></para><para><computeroutput><itemizedlist>
<listitem><para><bold>name</bold> is the loaded module name</para></listitem><listitem><para><bold>dag_conf</bold> is the name of the corresponding dag file of the component</para></listitem><listitem><para><bold>process_name</bold> is the name of the mainboard process once started, and the same component of process_name will be loaded and run in the same process.</para></listitem><listitem><para><bold>exception_handler</bold> is the handler method when the exception occurs in the process. The value can be exit or respawn listed below.<itemizedlist>
<listitem><para>exit, which means that the entire process needs to stop running when the current process exits abnormally.</para></listitem><listitem><para>respawn, the current process needs to be restarted after abnormal exit. Start this process. If there is no such thing as it is empty, it means no treatment. Can be controlled by the user according to the specific conditions of the process</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</computeroutput></para><para><computeroutput><heading level="2">Timer</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>Timer can be used to create a timed task to run on a periodic basis, or to run only once</computeroutput></para><para><computeroutput><heading level="3">Timer Interface</heading>
</computeroutput></para><para><computeroutput> ```C /**<itemizedlist>
<listitem><para>Construct a new Timer object</para></listitem><listitem></listitem><listitem><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>period</parametername>
</parameternamelist>
<parameterdescription>
<para>The period of the timer, unit is ms</para></parameterdescription>
</parameteritem>
</parameterlist>
</para></listitem><listitem><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callback</parametername>
</parameternamelist>
<parameterdescription>
<para>The tasks that the timer needs to perform</para></parameterdescription>
</parameteritem>
</parameterlist>
</para></listitem><listitem><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>oneshot</parametername>
</parameternamelist>
<parameterdescription>
<para>True: perform the callback only after the first timing cycle</para></parameterdescription>
</parameteritem>
</parameterlist>
</para></listitem><listitem><para>False: perform the callback every timed period</para></listitem></itemizedlist>
</computeroutput></para><para><computeroutput> Timer(uint32_t period, std::function&lt;void()&gt; callback, bool oneshot); ```</computeroutput></para><para><computeroutput>Or you could encapsulate the parameters into a timer option as follows:</computeroutput></para><para><computeroutput>```C struct TimerOption { uint32_t period; // The period of the timer, unit is ms std::function&lt;void()&gt; callback; // The tasks that the timer needs to perform bool oneshot; // True: perform the callback only after the first timing cycle // False: perform the callback every timed period }; /**<itemizedlist>
<listitem><para>Construct a new Timer object</para></listitem><listitem></listitem><listitem><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>opt</parametername>
</parameternamelist>
<parameterdescription>
<para>Timer option</para></parameterdescription>
</parameteritem>
</parameterlist>
explicit Timer(TimerOption opt); ```</para></listitem></itemizedlist>
</computeroutput></para><para><computeroutput><heading level="3">Start Timer</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>After creating a Timer instance, you must call <computeroutput>Timer::Start()</computeroutput> to start the timer.</computeroutput></para><para><computeroutput><heading level="3">Stop Timer</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>When you need to manually stop a timer that has already started, you can call the <computeroutput>Timer::Stop()</computeroutput> interface.</computeroutput></para><para><computeroutput><heading level="3">Demo - example</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>```C #include &lt;iostream&gt; #include &quot;cyber/cyber.h&quot; int main(int argc, char** argv) { cyber::Init(argv[0]); // Print current time every 100ms cyber::Timer timer(100, [](){ std::cout &lt;&lt; cyber::Time::Now() &lt;&lt; std::endl; }, false); timer.Start() sleep(1); timer.Stop(); } ```</computeroutput></para><para><computeroutput><heading level="2">Time API</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>Time is a class used to manage time; it can be used for current time acquisition, time-consuming calculation, time conversion, and so on.</computeroutput></para><para><computeroutput>The time interfaces are as follows:</computeroutput></para><para><computeroutput>```C // constructor, passing in a different value to construct Time Time(uint64_t nanoseconds); //uint64_t, in nanoseconds Time(int nanoseconds); // int type, unit: nanoseconds Time(double seconds); // double, in seconds Time(uint32_t seconds, uint32_t nanoseconds); // seconds seconds + nanoseconds nanoseconds Static Time Now(); // Get the current time Double ToSecond() const; // convert to seconds Uint64_t ToNanosecond() const; // Convert to nanoseconds Std::string ToString() const; // Convert to a string in the format &quot;2018-07-10 20:21:51.123456789&quot; Bool IsZero() const; // Determine if the time is 0</computeroutput></para><para><computeroutput>```</computeroutput></para><para><computeroutput>A code example can be seen below:</computeroutput></para><para><computeroutput>```C #include &lt;iostream&gt; #include &quot;cyber/cyber.h&quot; #include &quot;cyber/duration.h&quot; int main(int argc, char** argv) { cyber::Init(argv[0]); Time t1(1531225311123456789UL); std::cout &lt;&lt; t1.ToString() std::endl; // 2018-07-10 20:21:51.123456789 // Duration time interval Time t1(100); Duration d(200); Time t2(300); assert(d == (t1-t2)); // true }</computeroutput></para><para><computeroutput>```</computeroutput></para><para><computeroutput><heading level="2">Record file: Read and Write</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput><heading level="3">Reading the Reader file</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput><bold>RecordReader</bold> is the component used to read messages in the cyber framework. Each RecordReader can open an existing record file through the <computeroutput>Open</computeroutput> method, and the thread will asynchronously read the information in the record file. The user only needs to execute ReadMessage to extract the latest message in RecordReader, and then get the message information through GetCurrentMessageChannelName, GetCurrentRawMessage, GetCurrentMessageTime.</computeroutput></para><para><computeroutput><bold>RecordWriter</bold> is the component used to record messages in the cyber framework. Each RecordWriter can create a new record file through the Open method. The user only needs to execute WriteMessage and WriteChannel to write message and channel information, and the writing process is asynchronous.</computeroutput></para><para><computeroutput><heading level="3">Demo - example(cyber/examples/record.cc)</heading>
</computeroutput></para><para><computeroutput> Write 100 RawMessage to<computeroutput>TEST_FILE</computeroutput> through <computeroutput>test_write</computeroutput> method, then read them out through <computeroutput>test_read</computeroutput> method.</computeroutput></para><para><computeroutput>```c #include &lt;string&gt;</computeroutput></para><para><computeroutput>#include &quot;cyber/cyber.h&quot; #include &quot;cyber/message/raw_message.h&quot; #include &quot;cyber/proto/record.pb.h&quot; #include &quot;cyber/record/record_message.h&quot; #include &quot;cyber/record/record_reader.h&quot; #include &quot;cyber/record/record_writer.h&quot;</computeroutput></para><para><computeroutput>using <ref refid="classapollo_1_1cyber_1_1record_1_1RecordReader" kindref="compound">apollo::cyber::record::RecordReader</ref>; using <ref refid="classapollo_1_1cyber_1_1record_1_1RecordWriter" kindref="compound">apollo::cyber::record::RecordWriter</ref>; using <ref refid="structapollo_1_1cyber_1_1record_1_1RecordMessage" kindref="compound">apollo::cyber::record::RecordMessage</ref>; using <ref refid="structapollo_1_1cyber_1_1message_1_1RawMessage" kindref="compound">apollo::cyber::message::RawMessage</ref>;</computeroutput></para><para><computeroutput>const char CHANNEL_NAME_1[] = &quot;/test/channel1&quot;; const char CHANNEL_NAME_2[] = &quot;/test/channel2&quot;; const char MESSAGE_TYPE_1[] = &quot;apollo.cyber.proto.Test&quot;; const char MESSAGE_TYPE_2[] = &quot;apollo.cyber.proto.Channel&quot;; const char PROTO_DESC[] = &quot;1234567890&quot;; const char STR_10B[] = &quot;1234567890&quot;; const char TEST_FILE[] = &quot;test.record&quot;;</computeroutput></para><para><computeroutput>void test_write(const std::string &amp;writefile) { RecordWriter writer; writer.SetSizeOfFileSegmentation(0); writer.SetIntervalOfFileSegmentation(0); writer.Open(writefile); writer.WriteChannel(CHANNEL_NAME_1, MESSAGE_TYPE_1, PROTO_DESC); for (uint32_t i = 0; i &lt; 100; ++i) { auto msg = std::make_shared&lt;RawMessage&gt;(&quot;abc&quot; + std::to_string(i)); writer.WriteMessage(CHANNEL_NAME_1, msg, 888 + i); } writer.Close(); }</computeroutput></para><para><computeroutput>void test_read(const std::string &amp;readfile) { RecordReader reader(readfile); RecordMessage message; uint64_t msg_count = reader.GetMessageNumber(CHANNEL_NAME_1); AINFO &lt;&lt; &quot;MSGTYPE: &quot; &lt;&lt; reader.GetMessageType(CHANNEL_NAME_1); AINFO &lt;&lt; &quot;MSGDESC: &quot; &lt;&lt; reader.GetProtoDesc(CHANNEL_NAME_1);</computeroutput></para><para><computeroutput> // read all message uint64_t i = 0; uint64_t valid = 0; for (i = 0; i &lt; msg_count; ++i) { if (reader.ReadMessage(&amp;message)) { AINFO &lt;&lt; &quot;msg[&quot; &lt;&lt; i &lt;&lt; &quot;]-&gt; &quot; &lt;&lt; &quot;channel name: &quot; &lt;&lt; message.channel_name &lt;&lt; &quot;; content: &quot; &lt;&lt; message.content &lt;&lt; &quot;; msg time: &quot; &lt;&lt; message.time; valid++; } else { AERROR &lt;&lt; &quot;read msg[&quot; &lt;&lt; i &lt;&lt; &quot;] failed&quot;; } } AINFO &lt;&lt; &quot;static msg=================&quot;; AINFO &lt;&lt; &quot;MSG validmsg:totalcount: &quot; &lt;&lt; valid &lt;&lt; &quot;:&quot; &lt;&lt; msg_count; }</computeroutput></para><para><computeroutput>int main(int argc, char *argv[]) { apollo::cyber::Init(argv[0]); test_write(TEST_FILE); sleep(1); test_read(TEST_FILE); return 0; } ``` <heading level="4">Build and run</heading>
</computeroutput></para><para><computeroutput><itemizedlist>
<listitem><para>Build: bazel build cyber/examples/â€¦</para></listitem><listitem><para>Run: ./bazel-bin/cyber/examples/record</para></listitem><listitem><para>Examining result:</para></listitem></itemizedlist>
</computeroutput></para><para><computeroutput>``` I1124 16:56:27.248200 15118 record.cc:64] [record] msg[0]-&gt; channel name: /test/channel1; content: abc0; msg time: 888 I1124 16:56:27.248227 15118 record.cc:64] [record] msg[1]-&gt; channel name: /test/channel1; content: abc1; msg time: 889 I1124 16:56:27.248239 15118 record.cc:64] [record] msg[2]-&gt; channel name: /test/channel1; content: abc2; msg time: 890 I1124 16:56:27.248252 15118 record.cc:64] [record] msg[3]-&gt; channel name: /test/channel1; content: abc3; msg time: 891 I1124 16:56:27.248297 15118 record.cc:64] [record] msg[4]-&gt; channel name: /test/channel1; content: abc4; msg time: 892 I1124 16:56:27.248378 15118 record.cc:64] [record] msg[5]-&gt; channel name: /test/channel1; content: abc5; msg time: 893 ... I1124 16:56:27.250422 15118 record.cc:73] [record] static msg================= I1124 16:56:27.250434 15118 record.cc:74] [record] MSG validmsg:totalcount: 100:100 ```</computeroutput></para><para><computeroutput><heading level="2">API Directory</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput><heading level="3">Node API</heading>
</computeroutput></para><para><computeroutput> For additional information and examples, refer to <ulink url="#node">Node</ulink></computeroutput></para><para><computeroutput><heading level="3">API List</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>```C //create writer with user-define attr and message type auto CreateWriter(const proto::RoleAttributes&amp; role_attr) -&gt; std::shared_ptr&lt;transport::Writer&lt;MessageT&gt;&gt;; //create reader with user-define attr, callback and message type auto CreateReader(const proto::RoleAttributes&amp; role_attr, const croutine::CRoutineFunc&lt;MessageT&gt;&amp; reader_func) -&gt; std::shared_ptr&lt;transport::Reader&lt;MessageT&gt;&gt;; //create writer with specific channel name and message type auto CreateWriter(const std::string&amp; channel_name) -&gt; std::shared_ptr&lt;transport::Writer&lt;MessageT&gt;&gt;; //create reader with specific channel name, callback and message type auto CreateReader(const std::string&amp; channel_name, const croutine::CRoutineFunc&lt;MessageT&gt;&amp; reader_func) -&gt; std::shared_ptr&lt;transport::Reader&lt;MessageT&gt;&gt;; //create reader with user-define config, callback and message type auto CreateReader(const ReaderConfig&amp; config, const CallbackFunc&lt;MessageT&gt;&amp; reader_func) -&gt; std::shared_ptr&lt;cybertron::Reader&lt;MessageT&gt;&gt;; //create service with name and specific callback auto CreateService(const std::string&amp; service_name, const typename service::Service&lt;Request, Response&gt;::ServiceCallback&amp; service_calllback) -&gt; std::shared_ptr&lt;service::Service&lt;Request, Response&gt;&gt;; //create client with name to send request to server auto CreateClient(const std::string&amp; service_name) -&gt; std::shared_ptr&lt;service::Client&lt;Request, Response&gt;&gt;;</computeroutput></para><para><computeroutput>```</computeroutput></para><para><computeroutput><heading level="2">Writer API</heading>
</computeroutput></para><para><computeroutput> For additional information and examples, refer to <ulink url="#writer">Writer</ulink></computeroutput></para><para><computeroutput><heading level="3">API List</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>```C bool Write(const std::shared_ptr&lt;MessageT&gt;&amp; message); ```</computeroutput></para><para><computeroutput><heading level="2">Client API</heading>
</computeroutput></para><para><computeroutput> For additional information and examples, refer to <ulink url="#service-creation-and-use">Client</ulink></computeroutput></para><para><computeroutput><heading level="3">API List</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>```C SharedResponse SendRequest(SharedRequest request, const std::chrono::seconds&amp; timeout_s = std::chrono::seconds(5));SharedResponse SendRequest(const Request&amp; request, const std::chrono::seconds&amp; timeout_s = std::chrono::seconds(5)); ```</computeroutput></para><para><computeroutput><heading level="2">Parameter API</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>The interface that the user uses to perform parameter related operations:</computeroutput></para><para><computeroutput><itemizedlist>
<listitem><para>Set the parameter related API.</para></listitem><listitem><para>Read the parameter related API.</para></listitem><listitem><para>Create a ParameterService to provide parameter service related APIs for other nodes.</para></listitem><listitem><para>Create a ParameterClient that uses the parameters provided by other nodes to service related APIs.</para></listitem></itemizedlist>
</computeroutput></para><para><computeroutput>For additional information and examples, refer to <ulink url="##param-parameter-service">Parameter</ulink></computeroutput></para><para><computeroutput><heading level="3">API List - Setting parameters</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>```C Parameter(); // Name is empty, type is NOT_SET explicit Parameter(const Parameter&amp; parameter); explicit Parameter(const std::string&amp; name); // Type is NOT_SET Parameter(const std::string&amp; name, const bool bool_value); Parameter(const std::string&amp; name, const int int_value); Parameter(const std::string&amp; name, const int64_t int_value); Parameter(const std::string&amp; name, const float double_value); Parameter(const std::string&amp; name, const double double_value); Parameter(const std::string&amp; name, const std::string&amp; string_value); Parameter(const std::string&amp; name, const char* string_value); Parameter(const std::string&amp; name, const std::string&amp; msg_str, const std::string&amp; full_name, const std::string&amp; proto_desc); Parameter(const std::string&amp; name, const google::protobuf::Message&amp; msg); ```</computeroutput></para><para><computeroutput><heading level="3">API List - Reading parameters</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>```C inline ParamType type() const; inline std::string TypeName() const; inline std::string Descriptor() const; inline const std::string Name() const; inline bool AsBool() const; inline int64_t AsInt64() const; inline double AsDouble() const; inline const std::string AsString() const; std::string DebugString() const; template &lt;typename type&gt;=&quot;&quot;&gt; typename std::enable_if&lt;std::is_base_of&lt;google::protobuf::Message, Type&gt;::value, Type&gt;::type value() const; template &lt;typename type&gt;=&quot;&quot;&gt; typename std::enable_if&lt;std::is_integral&lt;Type&gt;::value &amp;&amp; !std::is_same&lt;Type, bool&gt;::value, Type&gt;::type value() const; template &lt;typename type&gt;=&quot;&quot;&gt; typename std::enable_if&lt;std::is_floating_point&lt;Type&gt;::value, Type&gt;::type value() const; template &lt;typename type&gt;=&quot;&quot;&gt; typename std::enable_if&lt;std::is_convertible&lt;Type, std::string&gt;::value, const std::string&amp;&gt;::type value() const; template &lt;typename type&gt;=&quot;&quot;&gt; typename std::enable_if&lt;std::is_same&lt;Type, bool&gt;::value, bool&gt;::type value() const; ```</computeroutput></para><para><computeroutput><heading level="3">API List - Creating parameter service</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>```C explicit ParameterService(const std::shared_ptr&lt;Node&gt;&amp; node); void SetParameter(const Parameter&amp; parameter); bool GetParameter(const std::string&amp; param_name, Parameter* parameter); bool ListParameters(std::vector&lt;Parameter&gt;* parameters);</computeroutput></para><para><computeroutput>```</computeroutput></para><para><computeroutput><heading level="3">API List - Creating parameter client</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>```C ParameterClient(const std::shared_ptr&lt;Node&gt;&amp; node, const std::string&amp; service_node_name); bool SetParameter(const Parameter&amp; parameter); bool GetParameter(const std::string&amp; param_name, Parameter* parameter); bool ListParameters(std::vector&lt;Parameter&gt;* parameters); ```</computeroutput></para><para><computeroutput><heading level="2">Timer API</heading>
</computeroutput></para><para><computeroutput> You can set the parameters of the Timer and call the start and stop interfaces to start the timer and stop the timer. For additional information and examples, refer to <ulink url="#timer">Timer</ulink></computeroutput></para><para><computeroutput><heading level="3">API List</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>```C Timer(uint32_t period, std::function&lt;void()&gt; callback, bool oneshot); Timer(TimerOption opt); void SetTimerOption(TimerOption opt); void Start(); void Stop(); ```</computeroutput></para><para><computeroutput><heading level="2">Time API</heading>
</computeroutput></para><para><computeroutput> For additional information and examples, refer to <ulink url="#use-of-time">Time</ulink></computeroutput></para><para><computeroutput><heading level="3">API List</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>```C static const Time MAX; static const Time MIN; Time() {} explicit Time(uint64_t nanoseconds); explicit Time(int nanoseconds); explicit Time(double seconds); Time(uint32_t seconds, uint32_t nanoseconds); Time(const Time&amp; other); static Time Now(); static Time MonoTime(); static void SleepUntil(const Time&amp; time); double ToSecond() const; uint64_t ToNanosecond() const; std::string ToString() const; bool IsZero() const; ```</computeroutput></para><para><computeroutput><heading level="2">Duration API</heading>
</computeroutput></para><para><computeroutput> Interval-related interface, used to indicate the time interval, can be initialized according to the specified nanosecond or second.</computeroutput></para><para><computeroutput><heading level="3">API List</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>```C <ref refid="namespaceapollo_1_1cyber_1_1croutine_1aae31aee73e46be40ab635496b4d9d1e2" kindref="member">Duration()</ref> {} Duration(int64_t nanoseconds); Duration(int nanoseconds); Duration(double seconds); Duration(uint32_t seconds, uint32_t nanoseconds); Duration(const Rate&amp; rate); Duration(const Duration&amp; other); double ToSecond() const; int64_t ToNanosecond() const; bool IsZero() const; void Sleep() const; ```</computeroutput></para><para><computeroutput><heading level="2">Rate API</heading>
</computeroutput></para><para><computeroutput> The frequency interface is generally used to initialize the time of the sleep frequency after the object is initialized according to the specified frequency.</computeroutput></para><para><computeroutput><heading level="3">API List</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>```C Rate(double frequency); Rate(uint64_t nanoseconds); Rate(const Duration&amp;); void Sleep(); void Reset(); Duration CycleTime() const; Duration ExpectedCycleTime() const { return expected_cycle_time_; } ```</computeroutput></para><para><computeroutput><heading level="2">RecordReader API</heading>
</computeroutput></para><para><computeroutput> The interface for reading the record file is used to read the message and channel information in the record file.</computeroutput></para><para><computeroutput><heading level="3">API List</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>```C RecordReader(); bool Open(const std::string&amp; filename, uint64_t begin_time = 0, uint64_t end_time = UINT64_MAX); void Close(); bool ReadMessage(); bool EndOfFile(); const std::string&amp; CurrentMessageChannelName(); std::shared_ptr&lt;RawMessage&gt; CurrentRawMessage(); uint64_t CurrentMessageTime(); ```</computeroutput></para><para><computeroutput><heading level="2">RecordWriter API</heading>
</computeroutput></para><para><computeroutput> The interface for writing the record file, used to record the message and channel information into the record file.</computeroutput></para><para><computeroutput><heading level="3">API List</heading>
</computeroutput></para><para><computeroutput></computeroutput></para><para><computeroutput>```C RecordWriter(); bool Open(const std::string&amp; file); void Close(); bool WriteChannel(const std::string&amp; name, const std::string&amp; type, const std::string&amp; proto_desc); template &lt;typename messaget&gt;=&quot;&quot;&gt; bool WriteMessage(const std::string&amp; channel_name, const MessageT&amp; message, const uint64_t time_nanosec, const std::string&amp; proto_desc = &quot;&quot;); bool SetSizeOfFileSegmentation(uint64_t size_kilobytes); bool SetIntervalOfFileSegmentation(uint64_t time_sec); ``` </computeroutput></para>    </detaileddescription>
  </compounddef>
</doxygen>
