<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.6">
  <compounddef id="md_docs_CyberRT_Migration_Guide" kind="page">
    <compoundname>md_docs_CyberRT_Migration_Guide</compoundname>
    <title>Migration guide from Apollo ROS</title>
    <detaileddescription>
<para>This article describes the essential changes for projects to migrate from Apollo ROS(3.0 and before) to Apollo Cyber-RT(3.5). We will be using the very first ROS project talker/listener as example to demostrate step by step migration instruction.</para><para><heading level="2">Build system</heading>
</para><para>ROS use <computeroutput>CMake</computeroutput> as its build system but Cyber-RT use <computeroutput>bazel</computeroutput>. In a ROS project, CmakeLists.txt and package.xml are required for defining build configs like build target, dependency, message files and so on. As for a Cyber-RT component, a single bazel BUILD file covers. Some key build config mappings are listed below.</para><para>Cmake</para><para>``` project(pb_msgs_example) add_proto_files( DIRECTORY proto FILES chatter.proto ) <heading level="2">Declare a C++ executable</heading>
</para><para>add_executable(pb_talker src/talker.cpp) target_link_libraries(pb_talker ${catkin_LIBRARIES}pb_msgs_example_proto) add_executable(pb_listener src/listener.cpp) target_link_libraries(pb_listener ${catkin_LIBRARIES} pb_msgs_example_proto) ```</para><para>Bazel</para><para>``` cc_binary( name = &quot;talker&quot;, srcs = [&quot;talker.cc&quot;], deps = [ &quot;//cyber&quot;, &quot;//cyber/examples/proto:examples_cc_proto&quot;, ], ) cc_binary( name = &quot;listener&quot;, srcs = [&quot;listener.cc&quot;], deps = [ &quot;//cyber&quot;, &quot;//cyber/examples/proto:examples_cc_proto&quot;, ], ) ``<computeroutput> We can find the mapping easily from the 2 file snippets. For example,</computeroutput>pb_talker<computeroutput>and</computeroutput>src/talker.cpp<computeroutput>in cmake</computeroutput>add_executable<computeroutput>setting map to</computeroutput>name = &quot;talker&quot;<computeroutput>and</computeroutput>srcs = [&quot;talker.cc&quot;]<computeroutput>in BUILD file</computeroutput>cc_binary`. <heading level="3">Proto</heading>
</para><para>Apollo ROS has customized to support proto message formate that a separate section <computeroutput>add_proto_files</computeroutput> and projectName_proto(<computeroutput>pb_msgs_example_proto</computeroutput>) in <computeroutput>target_link_libraries</computeroutput> are required to send message in proto formate. For config proto message in Cyber-RT, it&apos;s as simple as adding the target proto file path concantenated with name of <computeroutput>cc_proto_library</computeroutput> in <computeroutput>deps</computeroutput> setting. The <computeroutput>cc_proto_library</computeroutput> is set up in BUILD file under proto folder.</para><para>```C cc_proto_library( name = &quot;examples_cc_proto&quot;, deps = [ &quot;:examples_proto&quot;, ], ) proto_library( name = &quot;examples_proto&quot;, srcs = [ &quot;examples.proto&quot;, ], ) ```</para><para>The package definition has also changed in Cyber-RT. In Apollo ROS a fixed package <computeroutput>package pb_msgs;</computeroutput> is used for proto files, but in Cyber-RT, the proto file path <computeroutput>package apollo.cyber.examples.proto;</computeroutput> is used instead.</para><para><heading level="2">Folder structure</heading>
</para><para>As shown below, Cyber-RT remove the src folder and pull all source code in the same folder as BUILD file. BUILD file plays the same role as CMakeLists.txt plus package.xml. Both Cyber-RT and Apollo ROS talker/listener example have a proto folder for message proto files but Cyber-RT requires a separate BUILD file for proto folder to set up the proto library.</para><para><heading level="3">Apollo ROS</heading>
</para><para><itemizedlist>
<listitem><para>CMakeLists.txt</para></listitem><listitem><para>package.xml</para></listitem><listitem><para>proto<itemizedlist>
<listitem><para>chatter.proto</para></listitem></itemizedlist>
</para></listitem><listitem><para>src<itemizedlist>
<listitem><para>listener.cpp</para></listitem><listitem><para>talker.cpp</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para><para><heading level="3">Cyber-RT</heading>
</para><para><itemizedlist>
<listitem><para>BUILD</para></listitem><listitem><para>listener.ccc</para></listitem><listitem><para>talker.cc</para></listitem><listitem><para>proto<itemizedlist>
<listitem><para>BUILD</para></listitem><listitem><para>examples.proto (with chatter message)</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para><para><heading level="2">Update source code</heading>
</para><para><heading level="3">Listener</heading>
</para><para>Cyber-RT</para><para>```c #include &quot;cyber/cyber.h&quot; #include &quot;cyber/examples/proto/examples.pb.h&quot;</para><para>void MessageCallback( const std::shared_ptr&lt;apollo::cyber::examples::proto::Chatter&gt;&amp; msg) { AINFO &lt;&lt; &quot;Received message seq-&gt; &quot; &lt;&lt; msg-&gt;seq(); AINFO &lt;&lt; &quot;msgcontent-&gt;&quot; &lt;&lt; msg-&gt;content(); }</para><para>int main(int argc, char* argv[]) { // init cyber framework apollo::cyber::Init(argv[0]); // create listener node auto listener_node = <ref refid="namespaceapollo_1_1cyber_1ae369c5de0279f2a5745d0438d532bc89" kindref="member">apollo::cyber::CreateNode</ref>(&quot;listener&quot;); // create listener auto listener = listener_node-&gt;CreateReader&lt;apollo::cyber::examples::proto::Chatter&gt;( &quot;channel/chatter&quot;, MessageCallback); <ref refid="namespaceapollo_1_1cyber_1a7929114e78a9c595b0ee715968ca2712" kindref="member">apollo::cyber::WaitForShutdown()</ref>; return 0; } ``` ROS</para><para>```c #include &quot;ros/ros.h&quot; #include &quot;chatter.pb.h&quot;</para><para>void MessageCallback(const boost::shared_ptr&lt;pb_msgs::Chatter&gt;&amp; msg) { ROS_INFO_STREAM(&quot;Time: &quot; &lt;&lt; msg-&gt;stamp().sec() &lt;&lt; &quot;.&quot; &lt;&lt; msg-&gt;stamp().nsec()); ROS_INFO(&quot;I heard pb Chatter message: [%s]&quot;, msg-&gt;content().c_str()); }</para><para>int main(int argc, char** argv) { ros::init(argc, argv, &quot;listener&quot;); ros::NodeHandle n; ros::Subscriber pb_sub = n.subscribe(&quot;chatter&quot;, 1000, MessageCallback); ros::spin(); return 0; } ```</para><para>You can see easily from the two listener code above that Cyber-RT provides very similar API to for developers to migrate from ROS.</para><para><itemizedlist>
<listitem><para><computeroutput>ros::init(argc, argv, &quot;listener&quot;);</computeroutput> <ndash/>&gt; <computeroutput>apollo::cyber::Init(argv[0]);</computeroutput></para></listitem><listitem><para><computeroutput>ros::NodeHandle n;</computeroutput> <ndash/>&gt; <computeroutput>auto listener_node = <ref refid="namespaceapollo_1_1cyber_1ae369c5de0279f2a5745d0438d532bc89" kindref="member">apollo::cyber::CreateNode</ref>(&quot;listener&quot;);</computeroutput></para></listitem><listitem><para><computeroutput>ros::Subscriber pb_sub = n.subscribe(&quot;chatter&quot;, 1000, MessageCallback);</computeroutput> <ndash/>&gt; <computeroutput>auto listener = listener_node-&gt;CreateReader(&quot;channel/chatter&quot;, MessageCallback);</computeroutput></para></listitem><listitem><para><computeroutput>ros::spin();</computeroutput> <ndash/>&gt; <computeroutput><ref refid="namespaceapollo_1_1cyber_1a7929114e78a9c595b0ee715968ca2712" kindref="member">apollo::cyber::WaitForShutdown()</ref>;</computeroutput></para></listitem></itemizedlist>
</para><para>Note: for Cyber-RT, a listener node has to use <computeroutput>node-&gt;CreateReader&lt;messageType&gt;(channelName, callback)</computeroutput> to read data from channel.</para><para><heading level="3">Talker</heading>
</para><para>Cyber-RT</para><para>```C #include &quot;cyber/cyber.h&quot; #include &quot;cyber/examples/proto/examples.pb.h&quot;</para><para>using apollo::cyber::examples::proto::Chatter;</para><para>int main(int argc, char *argv[]) { // init cyber framework apollo::cyber::Init(argv[0]); // create talker node auto talker_node = <ref refid="namespaceapollo_1_1cyber_1ae369c5de0279f2a5745d0438d532bc89" kindref="member">apollo::cyber::CreateNode</ref>(&quot;talker&quot;); // create talker auto talker = talker_node-&gt;CreateWriter&lt;Chatter&gt;(&quot;channel/chatter&quot;); Rate rate(1.0); while (<ref refid="namespaceapollo_1_1cyber_1aafa5f9962b51918897897bbc0fdd802f" kindref="member">apollo::cyber::OK()</ref>) { static uint64_t seq = 0; auto msg = std::make_shared&lt;Chatter&gt;(); msg-&gt;set_timestamp(Time::Now().ToNanosecond()); msg-&gt;set_lidar_timestamp(Time::Now().ToNanosecond()); msg-&gt;set_seq(seq++); msg-&gt;set_content(&quot;Hello, apollo!&quot;); talker-&gt;Write(msg); AINFO &lt;&lt; &quot;talker sent a message!&quot;; rate.Sleep(); } return 0; } ```</para><para>ROS</para><para>```c #include &quot;ros/ros.h&quot; #include &quot;chatter.pb.h&quot;</para><para>#include &lt;sstream&gt;</para><para>int main(int argc, char** argv) { ros::init(argc, argv, &quot;talker&quot;); ros::NodeHandle n; ros::Publisher chatter_pub = n.advertise&lt;pb_msgs::Chatter&gt;(&quot;chatter&quot;, 1000); ros::Rate loop_rate(10); int count = 0; while (ros::ok()) { pb_msgs::Chatter msg; ros::Time now = ros::Time::now(); msg.mutable_stamp()-&gt;set_sec(now.sec); msg.mutable_stamp()-&gt;set_nsec(now.nsec); std::stringstream ss; ss &lt;&lt; &quot;Hello world &quot; &lt;&lt; count; msg.set_content(ss.str()); chatter_pub.publish(msg); ros::spinOnce(); loop_rate.sleep(); } return 0; } ``` Most of the mappings are illustrated in listener code above, the rest are listed here.</para><para><itemizedlist>
<listitem><para><computeroutput>ros::Publisher chatter_pub = n.advertise&lt;pb_msgs::Chatter&gt;(&quot;chatter&quot;, 1000);</computeroutput> <ndash/>&gt; <computeroutput>auto talker = talker_node-&gt;CreateWriter&lt;Chatter&gt;(&quot;channel/chatter&quot;);</computeroutput></para></listitem><listitem><para><computeroutput>chatter_pub.publish(msg);</computeroutput> <ndash/>&gt; <computeroutput>talker-&gt;Write(msg);</computeroutput></para></listitem></itemizedlist>
</para><para><heading level="2">Tools mapping</heading>
</para><para><table rows="4" cols="3"><row>
<entry thead="yes"><para>ROS </para></entry><entry thead="yes"><para>Cyber-RT </para></entry><entry thead="yes"><para>Note  </para></entry></row>
<row>
<entry thead="no"><para>rosbag </para></entry><entry thead="no"><para>cyber_recorder </para></entry><entry thead="no"><para>data file </para></entry></row>
<row>
<entry thead="no"><para>scripts/diagnostics.sh </para></entry><entry thead="no"><para>cyber_monitor </para></entry><entry thead="no"><para>channel debug </para></entry></row>
<row>
<entry thead="no"><para>offline_lidar_visualizer_tool </para></entry><entry thead="no"><para>cyber_visualizer </para></entry><entry thead="no"><para>point cloud visualizer </para></entry></row>
</table>
<heading level="2">ROS bag data migration</heading>
</para><para>The data file changed from ROS bag to Cyber record in Cyber-RT. Cyber-RT has a data migration tool <computeroutput>rosbag_to_record</computeroutput> for users to easily migrate data files before Apollo 3.0 (ROS) to Cyber-RT like the sample usage below.</para><para>```bash rosbag_to_record demo_3.0.bag demo_3.5.record ``` </para>    </detaileddescription>
  </compounddef>
</doxygen>
