{
    "docs": [
        {
            "location": "/", 
            "text": "Apollo Cyber RT\n\n\n\n\n\n\nApollo Cyber RT Quick Start\n: Everything you need to know about how to start developing your first application module on top of Apollo Cyber RT. \n\n\n\n\n\n\nApollo Cyber RT Developer Tools\n: Detailed guidance on how to use the developer tools from Apollo Cyber RT. \n\n\n\n\n\n\nApollo Cyber RT API for Developers\n: A comprehensive guide to explore all the APIs of Apollo Cyber RT, with many concrete examples in source code.\n\n\n\n\n\n\nApollo Cyber RT FAQs\n: Answers to the most frequently asked questions about Apollo Cyber RT.\n\n\n\n\n\n\nApollo Cyber RT Terms\n: Commonly used terminologies in Cyber RT documentation and code.\n\n\n\n\n\n\nCyberRT C++ API\n: The CyberRT C++ API documentation.\n\n\n\n\n\n\nCyberRT Python API\n: The CyberRT Python API documentation.\n\n\n\n\n\n\nMore documents to come soon!", 
            "title": "Apollo Cyber RT"
        }, 
        {
            "location": "/#apollo-cyber-rt", 
            "text": "Apollo Cyber RT Quick Start : Everything you need to know about how to start developing your first application module on top of Apollo Cyber RT.     Apollo Cyber RT Developer Tools : Detailed guidance on how to use the developer tools from Apollo Cyber RT.     Apollo Cyber RT API for Developers : A comprehensive guide to explore all the APIs of Apollo Cyber RT, with many concrete examples in source code.    Apollo Cyber RT FAQs : Answers to the most frequently asked questions about Apollo Cyber RT.    Apollo Cyber RT Terms : Commonly used terminologies in Cyber RT documentation and code.    CyberRT C++ API : The CyberRT C++ API documentation.    CyberRT Python API : The CyberRT Python API documentation.    More documents to come soon!", 
            "title": "Apollo Cyber RT"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/", 
            "text": "Cyber RT API for Developers\n\n\nThis document provides an extensive technical deep dive into how to create, manipulate and use Cyber RT's API.\n\n\nTable of Contents\n\n\n\n\nTalker-Listener\n\n\nService Creation and Use\n\n\nParam parameter service\n\n\nLog API\n\n\nBuilding a module based on Component\n\n\nLaunch\n\n\nTimer\n\n\nTime API\n\n\nRecord file: Read and Write\n\n\nC++ API Directory\n\n\nNode\n\n\nWriter\n\n\nClient\n\n\nParameter\n\n\nTimer\n\n\nTime\n\n\nDuration\n\n\nRate\n\n\nRecordReader\n\n\nRecordWriter\n\n\n\n\n\n\n\n\nTalker-Listener\n\n\nThe first part of demonstrating CyberRT API is to understand the Talker/Listener example. Following are three essential concepts: node (basic unit), reader(facility to read message) and writer(facility to write message) of the example.\n\n\nCreate a node\n\n\nIn the CyberRT framework, the node is the most fundamental unit, similar to the role of a \nhandle\n. When creating a specific functional object (writer, reader, etc.), you need to create it based on an existing node instance.\nThe node creation interface is as follows:\n\n\nstd::unique_ptr\nNode\n apollo::cyber::CreateNode(const std::string\n node_name, const std::string\n name_space = \n);\n\n\n\n\n\n\nParameters:\n\n\nnode_name: name of the node, globally unique identifier\n\n\nname_space: name of the space where the node is located \n\nname_space is empty by default. It is the name of the space concatenated with node_name. The format is /namespace/node_name\n\n\n\n\n\n\nReturn value - An exclusive smart pointer to Node\n\n\nError Conditions - when \ncyber::Init()\n has not called, the system is in an uninitialized state, unable to create a node, return nullptr\n\n\n\n\nCreate a writer\n\n\nThe writer is the basic facility used in CyberRT to send messages. Every writer corresponds to a channel with a specific data type.\nThe writer is created by the \nCreateWriter\n interface in the node class. The interfaces are listed as below:\n\n\ntemplate \ntypename MessageT\n\n   auto CreateWriter(const std::string\n channel_name)\n       -\n std::shared_ptr\nWriter\nMessageT\n;\ntemplate \ntypename MessageT\n\n   auto CreateWriter(const proto::RoleAttributes\n role_attr)\n       -\n std::shared_ptr\nWriter\nMessageT\n;\n\n\n\n\n\n\n\nParameters:\n\n\nchannel_name: the name of the channel to write to\n\n\nMessageT: The type of message to be written out\n\n\n\n\n\n\nReturn value - Shared pointer to the Writer object\n\n\n\n\nCreate a reader\n\n\nThe reader is the basic facility used in cyber to receive messages. Reader has to be bound to a callback function when it is created. When a new message arrives in the channel, the callback will be called.\nThe reader is created by the \nCreateReader\n interface of the node class. The interfaces are listed as below:\n\n\n   template \ntypename MessageT\n\n   auto CreateReader(const std::string\n channel_name, const std::function\nvoid(const std::shared_ptr\nMessageT\n)\n reader_func)\n       -\n std::shared_ptr\nReader\nMessageT\n;\n\n   template \ntypename MessageT\n\n   auto CreateReader(const ReaderConfig\n config,\n                     const CallbackFunc\nMessageT\n reader_func = nullptr)\n       -\n std::shared_ptr\ncyber::Reader\nMessageT\n;\n\n   template \ntypename MessageT\n\n   auto CreateReader(const proto::RoleAttributes\n role_attr,\n                     const CallbackFunc\nMessageT\n reader_func = nullptr)\n   -\n std::shared_ptr\ncyber::Reader\nMessageT\n;\n\n\n\n\n\n\n\n\nParameters:\n\n\n\n\nMessageT: The type of message to read\n\n\nchannel_name: the name of the channel to receive from\n\n\nreader_func: callback function to process the messages\n\n\n\n\n\n\n\n\nReturn value - Shared pointer to the Reader object\n\n\n\n\n\n\nCode Example\n\n\nTalker (cyber/examples/talker.cc)\n\n\n#include \ncyber/cyber.h\n\n#include \ncyber/proto/chatter.pb.h\n\n#include \ncyber/time/rate.h\n\n#include \ncyber/time/time.h\n\nusing apollo::cyber::Rate;\nusing apollo::cyber::Time;\nusing apollo::cyber::proto::Chatter;\nint main(int argc, char *argv[]) {\n  // init cyber framework\n  apollo::cyber::Init(argv[0]);\n  // create talker node\n  std::shared_ptr\napollo::cyber::Node\n talker_node(\n      apollo::cyber::CreateNode(\ntalker\n));\n  // create talker\n  auto talker = talker_node-\nCreateWriter\nChatter\n(\nchannel/chatter\n);\n  Rate rate(1.0);\n  while (apollo::cyber::OK()) {\n    static uint64_t seq = 0;\n    auto msg = std::make_shared\napollo::cyber::proto::Chatter\n();\n    msg-\nset_timestamp(Time::Now().ToNanosecond());\n    msg-\nset_lidar_timestamp(Time::Now().ToNanosecond());\n    msg-\nset_seq(seq++);\n    msg-\nset_content(\nHello, apollo!\n);\n    talker-\nWrite(msg);\n    AINFO \n \ntalker sent a message!\n;\n    rate.Sleep();\n  }\n  return 0;\n}\n\n\n\n\nListener (cyber/examples/listener.cc)\n\n\n#include \ncyber/cyber.h\n\n#include \ncyber/proto/chatter.pb.h\n\nvoid MessageCallback(\n    const std::shared_ptr\napollo::cyber::proto::Chatter\n msg) {\n  AINFO \n \nReceived message seq-\n \n \n msg-\nseq();\n  AINFO \n \nmsgcontent-\n \n msg-\ncontent();\n}\nint main(int argc, char *argv[]) {\n  // init cyber framework\n  apollo::cyber::Init(argv[0]);  \n  // create listener node\n  auto listener_node = apollo::cyber::CreateNode(\nlistener\n);\n  // create listener\n  auto listener =\n      listener_node-\nCreateReader\napollo::cyber::proto::Chatter\n(\n          \nchannel/chatter\n, MessageCallback);\n  apollo::cyber::WaitForShutdown();\n  return 0;\n}\n\n\n\n\nBazel BUILD file(cyber/samples/BUILD)\n\n\ncc_binary(\n    name = \ntalker\n,\n    srcs = [ \ntalker.cc\n, ],\n    deps = [\n        \n//cyber\n,\n        \n//cyber/examples/proto:examples_cc_proto\n,\n    ],\n)\n\ncc_binary(\n    name = \nlistener\n,\n    srcs = [ \nlistener.cc\n, ],\n    deps = [\n        \n//cyber\n,\n        \n//cyber/examples/proto:examples_cc_proto\n,\n    ],\n)\n\n\n\n\nBuild and Run\n\n\n\n\nBuild: bazel build cyber/examples/\u2026\n\n\nRun talker/listener in different terminals:   \n\n\n./bazel-bin/cyber/examples/talker\n\n\n./bazel-bin/cyber/examples/listener\n\n\n\n\n\n\nExamine the results: you should see message printing out on listener. \n\n\n\n\nService Creation and Use\n\n\nIntroduction\n\n\nIn an autonomous driving system, there are many scenarios that require more from module communication than just sending or receiving messages. Service is another way of communication between nodes. Unlike channel, service implements \ntwo-way\n communication, e.g. a node obtains a response by sending a request. This section introduces the \nservice\n module in CyberRT API with examples.\n\n\nDemo - Example\n\n\nProblem: create a client-server model that pass Driver.proto back and forth.\nWhen a request is sent in by the client, the server parses/processes the request and returns the response.\n\n\nThe implementation of the demo mainly includes the following steps.\n\n\nDefine request and response messages\n\n\nAll messages in cyber are in the \nprotobuf\n format. Any protobuf message with serialize/deserialize interfaces can be used as the service request and response message. \nDriver\n in examples.proto is used as service request and response in this example:\n\n\n// filename: examples.proto\nsyntax = \nproto2\n;\npackage apollo.cyber.examples.proto;\nmessage Driver {\n    optional string content = 1;\n    optional uint64 msg_id = 2;\n    optional uint64 timestamp = 3;\n};\n\n\n\n\nCreate a service and a client\n\n\n// filename: cyber/examples/service.cc\n#include \ncyber/cyber.h\n\n#include \ncyber/examples/proto/examples.pb.h\n\n\nusing apollo::cyber::examples::proto::Driver;\n\nint main(int argc, char* argv[]) {\n  apollo::cyber::Init(argv[0]);\n  std::shared_ptr\napollo::cyber::Node\n node(\n      apollo::cyber::CreateNode(\nstart_node\n));\n  auto server = node-\nCreateService\nDriver, Driver\n(\n      \ntest_server\n, [](const std::shared_ptr\nDriver\n request,\n                        std::shared_ptr\nDriver\n response) {\n        AINFO \n \nserver: I am driver server\n;\n        static uint64_t id = 0;\n        ++id;\n        response-\nset_msg_id(id);\n        response-\nset_timestamp(0);\n      }); \n  auto client = node-\nCreateClient\nDriver, Driver\n(\ntest_server\n);\n  auto driver_msg = std::make_shared\nDriver\n();\n  driver_msg-\nset_msg_id(0);\n  driver_msg-\nset_timestamp(0);\n  while (apollo::cyber::OK()) {\n    auto res = client-\nSendRequest(driver_msg);\n    if (res != nullptr) {\n      AINFO \n \nclient: responese: \n \n res-\nShortDebugString();\n    } else {\n      AINFO \n \nclient: service may not ready.\n;\n    }   \n    sleep(1);\n  }\n\n  apollo::cyber::WaitForShutdown();\n  return 0;\n}\n\n\n\n\nBazel build file\n\n\ncc_binary(\n    name = \nservice\n,\n    srcs = [ \nservice.cc\n, ],\n    deps = [\n        \n//cyber\n,\n        \n//cyber/examples/proto:examples_cc_proto\n,\n    ],\n)\n\n\n\n\nBuild and run\n\n\n\n\nBuild service/client: bazel build cyber/examples/\u2026\n\n\nRun: ./bazel-bin/cyber/examples/service\n\n\nExamining result: you should see content below in apollo/data/log/service.INFO \n\n\n\n\nI1124 16:36:44.568845 14965 service.cc:30] [service] server: i am driver server\nI1124 16:36:44.569031 14949 service.cc:43] [service] client: responese: msg_id: 1 timestamp: 0\nI1124 16:36:45.569514 14966 service.cc:30] [service] server: i am driver server\nI1124 16:36:45.569932 14949 service.cc:43] [service] client: responese: msg_id: 2 timestamp: 0\nI1124 16:36:46.570627 14967 service.cc:30] [service] server: i am driver server\nI1124 16:36:46.571024 14949 service.cc:43] [service] client: responese: msg_id: 3 timestamp: 0\nI1124 16:36:47.571566 14968 service.cc:30] [service] server: i am driver server\nI1124 16:36:47.571962 14949 service.cc:43] [service] client: responese: msg_id: 4 timestamp: 0\nI1124 16:36:48.572634 14969 service.cc:30] [service] server: i am driver server\nI1124 16:36:48.573030 14949 service.cc:43] [service] client: responese: msg_id: 5 timestamp: 0\n\n\n\n\nPrecautions\n\n\n\n\nWhen registering a service, note that duplicate service names are not allowed\n\n\nThe node name applied when registering the server and client should not be duplicated either\n\n\n\n\nParameter Service\n\n\nThe Parameter Service is used for shared data between nodes, and provides basic operations such as \nset\n, \nget\n, and \nlist\n. The Parameter Service is based on the \nService\n implementation and contains service and client.\n\n\nParameter Object\n\n\nSupported Data types\n\n\nAll parameters passed through cyber are \napollo::cyber::Parameter\n objects, the table below lists the 5 supported parameter types.  \n\n\n\n\n\n\n\n\nParameter type\n\n\nC++ data type\n\n\nprotobuf data type\n\n\n\n\n\n\n\n\n\n\napollo::cyber::proto::ParamType::INT\n\n\nint64_t\n\n\nint64\n\n\n\n\n\n\napollo::cyber::proto::ParamType::DOUBLE\n\n\ndouble\n\n\ndouble\n\n\n\n\n\n\napollo::cyber::proto::ParamType::BOOL\n\n\nbool\n\n\nbool\n\n\n\n\n\n\napollo::cyber::proto::ParamType::STRING\n\n\nstd::string\n\n\nstring\n\n\n\n\n\n\napollo::cyber::proto::ParamType::PROTOBUF\n\n\nstd::string\n\n\nstring\n\n\n\n\n\n\napollo::cyber::proto::ParamType::NOT_SET\n\n\n-\n\n\n-\n\n\n\n\n\n\n\n\nBesides the 5 types above, Parameter also supports interface with protobuf object as incoming parameter. Post performing serialization processes the object and converts it to the STRING type for transfer.\n\n\nCreating the Parameter Object\n\n\nSupported constructors:\n\n\n  Parameter();  // Name is empty, type is NOT_SET\n  explicit Parameter(const Parameter\n parameter);\n  explicit Parameter(const std::string\n name);  // type\u4e3aNOT_SET\n  Parameter(const std::string\n name, const bool bool_value);  \n  Parameter(const std::string\n name, const int int_value);\n  Parameter(const std::string\n name, const int64_t int_value);\n  Parameter(const std::string\n name, const float double_value);\n  Parameter(const std::string\n name, const double double_value);\n  Parameter(const std::string\n name, const std::string\n string_value);\n  Parameter(const std::string\n name, const char* string_value);\n  Parameter(const std::string\n name, const std::string\n msg_str,\n            const std::string\n full_name, const std::string\n proto_desc);\n  Parameter(const std::string\n name, const google::protobuf::Message\n msg);\n\n\n\n\nSample code of using Parameter object:\n\n\nC\n  Parameter a(\"int\", 10);\n  Parameter b(\"bool\", true);\n  Parameter c(\"double\", 0.1);\n  Parameter d(\"string\", \"cyber\");\n  Parameter e(\"string\", std::string(\"cyber\"));\n  // proto message Chatter\n  Chatter chatter;\n  Parameter f(\"chatter\", chatter);\n  std::string msg_str(\"\");\n  chatter.SerializeToString(\nmsg_str);\n  std::string msg_desc(\"\");\n  ProtobufFactory::GetDescriptorString(chatter, \nmsg_desc);\n  Parameter g(\"chatter\", msg_str, Chatter::descriptor()-\nfull_name(), msg_desc);\n\n\nInterface and Data Reading\n\n\nInterface list:\n\n\n  inline ParamType type() const;\n  inline std::string TypeName() const;\n  inline std::string Descriptor() const;\n  inline const std::string Name() const;\n  inline bool AsBool() const;\n  inline int64_t AsInt64() const;\n  inline double AsDouble() const;\n  inline const std::string AsString() const;\n  std::string DebugString() const;\n  template \ntypename Type\n\n  typename std::enable_if\nstd::is_base_of\ngoogle::protobuf::Message, Type\n::value, Type\n::type\n  value() const;\n  template \ntypename Type\n\n  typename std::enable_if\nstd::is_integral\nType\n::value \n !std::is_same\nType, bool\n::value, Type\n::type\n  value() const;\n  template \ntypename Type\n\n  typename std::enable_if\nstd::is_floating_point\nType\n::value, Type\n::type\n  value() const;\n  template \ntypename Type\n\n  typename std::enable_if\nstd::is_convertible\nType, std::string\n::value, const std::string\n::type\n  value() const;\n  template \ntypename Type\n\n  typename std::enable_if\nstd::is_same\nType, bool\n::value, bool\n::type \n  value() const;\n\n\n\n\nAn example of how to use those interfaces:\n\n\n  Parameter a(\nint\n, 10);\n  a.Name();  // return int\n  a.Type();  // return apollo::cyber::proto::ParamType::INT\n  a.TypeName();  // return string: INT\n  a.DebugString();  // return string: {name: \nint\n, type: \nINT\n, value: 10}\n  int x = a.AsInt64();  // x = 10\n  x = a.value\nint64_t\n();  // x = 10\n  x = a.AsString();  // Undefined behavior, error log prompt\n  f.TypeName();  // return string: chatter\n  auto chatter = f.value\nChatter\n();\n\n\n\n\nParameter Service\n\n\nIf a node wants to provide a Parameter Service to other nodes, then you need to create a \nParameterService\n.\n\n\n/**\n   * @brief Construct a new ParameterService object\n   * \n   * @param node shared_ptr of the node handler\n   */\n  explicit ParameterService(const std::shared_ptr\nNode\n node);\n\n\n\n\nSince all parameters are stored in the parameter service object, the parameters can be manipulated directly in the ParameterService without sending a service request.\n\n\nSetting parameters:\n\n\n /**\n  * @brief Set the Parameter object\n  *\n  * @param parameter parameter to be set\n  */\n  void SetParameter(const Parameter\n parameter);\n\n\n\n\nGetting parameters:\n\n\n  /**\n   * @brief Get the Parameter object\n   * \n   * @param param_name \n   * @param parameter the pointer to store \n   * @return true \n   * @return false call service fail or timeout\n   */\n  bool GetParameter(const std::string\n param_name, Parameter* parameter);\n\n\n\n\nGetting the list of parameters:\n\n\n /**\n   * @brief Get all the Parameter objects\n   *\n   * @param parameters pointer of vector to store all the parameters\n   * @return true\n   * @return false call service fail or timeout\n   */\n  bool ListParameters(std::vector\nParameter\n* parameters);\n\n\n\n\nParameter Client\n\n\nIf a node wants to use parameter services of other nodes, you need to create a \nParameterClient\n.\n\n\n/**\n   * @brief Construct a new ParameterClient object\n   *\n   * @param node shared_ptr of the node handler\n   * @param service_node_name node name which provide a param services\n   */\n  ParameterClient(const std::shared_ptr\nNode\n node, const std::string\n service_node_name);\n\n\n\n\nYou could also perform \nSetParameter\n, \nGetParameter\n and \nListParameters\n mentioned under \nParameter Service\n.\n\n\nDemo - example\n\n\n#include \ncyber/cyber.h\n\n#include \ncyber/parameter/parameter_client.h\n\n#include \ncyber/parameter/parameter_server.h\n\n\nusing apollo::cyber::Parameter;\nusing apollo::cyber::ParameterServer;\nusing apollo::cyber::ParameterClient;\n\nint main(int argc, char** argv) {\n  apollo::cyber::Init(*argv);\n  std::shared_ptr\napollo::cyber::Node\n node =\n      apollo::cyber::CreateNode(\nparameter\n);\n  auto param_server = std::make_shared\nParameterServer\n(node);\n  auto param_client = std::make_shared\nParameterClient\n(node, \nparameter\n);\n  param_server-\nSetParameter(Parameter(\nint\n, 1));\n  Parameter parameter;\n  param_server-\nGetParameter(\nint\n, \nparameter);\n  AINFO \n \nint: \n \n parameter.AsInt64();\n  param_client-\nSetParameter(Parameter(\nstring\n, \ntest\n));\n  param_client-\nGetParameter(\nstring\n, \nparameter);\n  AINFO \n \nstring: \n \n parameter.AsString();\n  param_client-\nGetParameter(\nint\n, \nparameter);\n  AINFO \n \nint: \n \n parameter.AsInt64();\n  return 0;\n}\n\n\n\n\nBuild and run\n\n\n\n\nBuild: bazel build cyber/examples/\u2026\n\n\nRun: ./bazel-bin/cyber/examples/paramserver\n\n\n\n\nLog API\n\n\nLog library\n\n\nCyber log library is built on top of glog. The following header files need to be included:\n\n\n#include \ncyber/common/log.h\n\n#include \ncyber/init.h\n\n\n\n\n\nLog configuration\n\n\nDefault global config path: cyber/setup.bash\n\n\nThe configs below could be modified by devloper:\n\n\nexport GLOG_log_dir=/apollo/data/log\nexport GLOG_alsologtostderr=0\nexport GLOG_colorlogtostderr=1\nexport GLOG_minloglevel=0\n\n\n\n\nLog initialization\n\n\nCall the Init method at the code entry to initialize the log:\n\n\napollo::cyber::cyber::Init(argv[0]) is initialized. \nIf no macro definition is made in the previous component, the corresponding log is printed to the binary log.\n\n\n\n\nLog output macro\n\n\nLog library is encapsulated in Log printing macros. The related log macros are used as follows:\n\n\nADEBUG \n \nhello cyber.\n;\nAINFO  \n \nhello cyber.\n;\nAWARN  \n \nhello cyber.\n;\nAERROR \n \nhello cyber.\n;\nAFATAL \n \nhello cyber.\n;\n\n\n\n\n\nLog format\n\n\nThe format is \nMODULE_NAME\n.log.\nLOG_LEVEL\n.\ndatetime\n.\nprocess_id\n\n\nAbout log files\n\n\nCurrently, the only different output behavior from default glog is that different log levels of a module will be written into the same log file.\n\n\nBuilding a module based on Component\n\n\nKey concepts\n\n\n1. Component\n\n\nThe component is the base class that Cyber-RT provides to build application modules. Each specific application module can inherit the Component class and define its own \nInit\n and \nProc\n functions so that it can be loaded into the Cyber framework.\n\n\n2. Binary vs Component\n\n\nThere are two options to use Cyber-RT framework for applications:\n\n\n\n\nBinary based: the application is compiled separately into a binary, which communicates with other cyber modules by creating its own \nReader\n and \nWriter\n.\n\n\nComponent based: the application is compiled into a Shared Library. By inheriting the Component class and writing the corresponding dag description file, the Cyber-RT framework will load and run the application dynamically.\n\n\n\n\nThe essential Component interface\n\n\n\n\nThe component's \nInit()\n function is like the main function that does some initialization of the algorithm.\n\n\nComponent's \nProc()\n function works like Reader's callback function that is called by the framework when a message arrives.\n\n\n\n\nAdvantages of using Component\n\n\n\n\nComponent can be loaded into different processes through the launch file, and the deployment is flexible.\n\n\nComponent can change the received channel name by modifying the dag file without recompiling.\n\n\nComponent supports receiving multiple types of data.\n\n\nComponent supports providing multiple fusion strategies.\n\n\n\n\n3. Dag file format\n\n\nAn example dag file:\n\n\n  # Define all coms in DAG streaming.\n    module_config {\n    module_library : \nlib/libperception_component.so\n\n    components {\n        class_name : \nPerceptionComponent\n\n        config {\n            name : \nperception\n\n            readers {\n                channel: \nperception/channel_name\n\n            }\n        }\n    }\n    timer_components {\n        class_name : \nDriverComponent\n\n        config {\n            name : \ndriver\n\n            interval : 100\n        }\n    }\n    }\n\n\n\n\n\n\nmodule_library\n: If you want to load the .so library the root directory is the working directory of cyber (the same directory of \nsetup.bash\n)\n\n\ncomponents \n timer_component\n: Select the base component class type that needs to be loaded.\n\n\nclass_name\n: the name of the component class to load\n\n\nname\n: the loaded class_name as the identifier of the loading example\n\n\nreaders\n: Data received by the current component, supporting 1-3 channels of data.\n\n\n\n\nDemo - examples\n\n\nCommon_component_example(cyber/examples/common_component_example/*)\n\n\nHeader definition(common_component_example.h)\n\n\n#include \nmemory\n\n\n#include \ncyber/class_loader/class_loader.h\n\n#include \ncyber/component/component.h\n\n#include \ncyber/examples/proto/examples.pb.h\n\n\nusing apollo::cyber::examples::proto::Driver;\nusing apollo::cyber::Component;\nusing apollo::cyber::ComponentBase;\n\nclass Commontestcomponent : public Component\nDriver, Driver\n {\n public:\n  bool Init() override;\n  bool Proc(const std::shared_ptr\nDriver\n msg0,\n            const std::shared_ptr\nDriver\n msg1) override;\n};\nCYBER_REGISTER_COMPONENT(Commontestcomponent)\n\n\n\n\nCpp file implementation(common_component_example.cc)\n\n\n#include \ncyber/examples/common_component_smaple/common_component_example.h\n\n\n#include \ncyber/class_loader/class_loader.h\n\n#include \ncyber/component/component.h\n\n\nbool Commontestcomponent::Init() {\n  AINFO \n \nCommontest component init\n;\n  return true;\n}\n\nbool Commontestcomponent::Proc(const std::shared_ptr\nDriver\n msg0,\n                               const std::shared_ptr\nDriver\n msg1) {\n  AINFO \n \nStart commontest component Proc [\n \n msg0-\nmsg_id() \n \n] [\n\n        \n msg1-\nmsg_id() \n \n]\n;\n  return true;\n}\n\n\n\n\nTimer_component_example(cyber/examples/timer_component_example/*)\n\n\nHeader definition(timer_component_example.h)\n\n\n#include \nmemory\n\n\n#include \ncyber/class_loader/class_loader.h\n\n#include \ncyber/component/component.h\n\n#include \ncyber/component/timer_component.h\n\n#include \ncyber/examples/proto/examples.pb.h\n\n\nusing apollo::cyber::examples::proto::Driver;\nusing apollo::cyber::Component;\nusing apollo::cyber::ComponentBase;\nusing apollo::cyber::TimerComponent;\nusing apollo::cyber::Writer;\n\nclass TimertestComponent : public TimerComponent {\n public:\n  bool Init() override;\n  bool Proc() override;\n\n private:\n  std::shared_ptr\nWriter\nDriver\n driver_writer_ = nullptr;\n};\nCYBER_REGISTER_COMPONENT(TimertestComponent)\n\n\n\n\nCpp file implementation(timer_component_example.cc)\n\n\n#include \ncyber/examples/timer_component_example/timer_component_example.h\n\n\n#include \ncyber/class_loader/class_loader.h\n\n#include \ncyber/component/component.h\n\n#include \ncyber/examples/proto/examples.pb.h\n\n\nbool TimertestComponent::Init() {\n  driver_writer_ = node_-\nCreateWriter\nDriver\n(\n/carstatus/channel\n);\n  return true;\n}\n\nbool TimertestComponent::Proc() {\n  static int i = 0;\n  auto out_msg = std::make_shared\nDriver\n();\n  out_msg-\nset_msg_id(i++);\n  driver_writer_-\nWrite(out_msg);\n  AINFO \n \ntimertestcomponent: Write drivermsg-\n\n        \n out_msg-\nShortDebugString();\n  return true;\n}\n\n\n\n\nBuild and run\n\n\nUse timertestcomponent as example:\n\n\n\n\nBuild: bazel build cyber/examples/timer_component_smaple/\u2026\n\n\nRun: mainboard -d cyber/examples/timer_component_smaple/timer.dag\n\n\n\n\nPrecautions\n\n\n\n\nComponent needs to be registered to load the class through SharedLibrary. The registration interface looks like:\n\n\n\n\nCYBER_REGISTER_CLASS(DriverComponent)\n\n\n\n\nIf you use a namespace when registering, you also need to add a namespace when you define it in the dag file.\n\n\n\n\nThe configuration files of the Component and TimerComponent are different, please be careful not to mix the two up.\n\n\n\n\nLaunch\n\n\ncyber_launch\n is the launcher of the Cyber-RT framework. It starts multiple mainboards according to the launch file, and loads different components into different mainboards according to the dag file.\ncyber_launch supports two scenarios for dynamically loading components or starting Binary programs in a child process.\n\n\nLaunch File Format\n\n\ncyber\n\n    \nmodule\n\n        \nname\ndriver\n/name\n\n        \ndag_conf\ndriver.dag\n/dag_conf\n\n        \nprocess_name\n/process_name\n\n        \nexception_handler\nexit\n/exception_handler\n\n    \n/module\n\n    \nmodule\n\n        \nname\nperception\n/name\n\n        \ndag_conf\nperception.dag\n/dag_conf\n\n        \nprocess_name\n/process_name\n\n        \nexception_handler\nrespawn\n/exception_handler\n\n    \n/module\n\n    \nmodule\n\n        \nname\nplanning\n/name\n\n        \ndag_conf\nplanning.dag\n/dag_conf\n\n        \nprocess_name\n/process_name\n\n    \n/module\n\n\n/cyber\n\n\n\n\n\nModule\n:\nEach loaded component or binary is a module\n\n\n\n\nname\n is the loaded module name\n\n\ndag_conf\n is the name of the corresponding dag file of the component\n\n\nprocess_name\n is the name of the mainboard process once started, and the same component of process_name will be loaded and run in the same process.\n\n\nexception_handler\n is the handler method when the exception occurs in the process. The value can be exit or respawn listed below.\n\n\nexit, which means that the entire process needs to stop running when the current process exits abnormally. \n\n\nrespawn, the current process needs to be restarted after abnormal exit. Start this process. If there is no such thing as it is empty, it means no treatment. Can be controlled by the user according to the specific conditions of the process\n\n\n\n\n\n\n\n\nTimer\n\n\nTimer can be used to create a timed task to run on a periodic basis, or to run only once\n\n\nTimer Interface\n\n\n/**\n   * @brief Construct a new Timer object\n   *\n   * @param period The period of the timer, unit is ms\n   * @param callback The tasks that the timer needs to perform\n   * @param oneshot True: perform the callback only after the first timing cycle\n   *                False: perform the callback every timed period\n   */\n  Timer(uint32_t period, std::function\nvoid()\n callback, bool oneshot);\n\n\n\n\nOr you could encapsulate the parameters into a timer option as follows:\n\n\nstruct TimerOption {\n  uint32_t period;                 // The period of the timer, unit is ms\n  std::function\nvoid()\n callback;  // The tasks that the timer needs to perform\n  bool oneshot;  // True: perform the callback only after the first timing cycle\n                 // False: perform the callback every timed period\n};\n/**\n   * @brief Construct a new Timer object\n   * \n   * @param opt Timer option\n   */\n  explicit Timer(TimerOption opt);\n\n\n\n\nStart Timer\n\n\nAfter creating a Timer instance, you must call \nTimer::Start()\n to start the timer.\n\n\nStop Timer\n\n\nWhen you need to manually stop a timer that has already started, you can call the \nTimer::Stop()\n interface.\n\n\nDemo - example\n\n\n#include \niostream\n\n#include \ncyber/cyber.h\n\nint main(int argc, char** argv) {\n    cyber::Init(argv[0]);\n    // Print current time every 100ms\n    cyber::Timer timer(100, [](){\n        std::cout \n cyber::Time::Now() \n std::endl;\n    }, false);\n    timer.Start()\n    sleep(1);\n    timer.Stop();\n}\n\n\n\n\nTime API\n\n\nTime is a class used to manage time; it can be used for current time acquisition, time-consuming calculation, time conversion, and so on.\n\n\nThe time interfaces are as follows:\n\n\n// constructor, passing in a different value to construct Time\nTime(uint64_t nanoseconds); //uint64_t, in nanoseconds\nTime(int nanoseconds); // int type, unit: nanoseconds\nTime(double seconds); // double, in seconds\nTime(uint32_t seconds, uint32_t nanoseconds); \n// seconds seconds + nanoseconds nanoseconds\nStatic Time Now(); // Get the current time\nDouble ToSecond() const; // convert to seconds\nUint64_t ToNanosecond() const; // Convert to nanoseconds\nStd::string ToString() const; // Convert to a string in the format \n2018-07-10 20:21:51.123456789\n\nBool IsZero() const; // Determine if the time is 0\n\n\n\n\n\nA code example can be seen below:\n\n\n#include \niostream\n\n#include \ncyber/cyber.h\n\n#include \ncyber/duration.h\n\nint main(int argc, char** argv) {\n    cyber::Init(argv[0]);\n    Time t1(1531225311123456789UL);\n    std::cout \n t1.ToString() std::endl; // 2018-07-10 20:21:51.123456789\n    // Duration time interval\n    Time t1(100);\n    Duration d(200);\n    Time t2(300);\n    assert(d == (t1-t2)); // true\n}\n\n\n\n\n\nRecord file: Read and Write\n\n\nReading the Reader file\n\n\nRecordReader\n is the component used to read messages in the cyber framework. Each RecordReader can open an existing record file through the \nOpen\n method, and the thread will asynchronously read the information in the record file. The user only needs to execute ReadMessage to extract the latest message in RecordReader, and then get the message information through GetCurrentMessageChannelName, GetCurrentRawMessage, GetCurrentMessageTime.\n\n\nRecordWriter\n is the component used to record messages in the cyber framework. Each RecordWriter can create a new record file through the Open method. The user only needs to execute WriteMessage and WriteChannel to write message and channel information, and the writing process is asynchronous.\n\n\nDemo - example(cyber/examples/record.cc)\n\n\nWrite 100 RawMessage to\nTEST_FILE\n through \ntest_write\n method, then read them out through \ntest_read\n method.\n\n\n#include \nstring\n\n\n#include \ncyber/cyber.h\n\n#include \ncyber/message/raw_message.h\n\n#include \ncyber/proto/record.pb.h\n\n#include \ncyber/record/record_message.h\n\n#include \ncyber/record/record_reader.h\n\n#include \ncyber/record/record_writer.h\n\n\nusing ::apollo::cyber::record::RecordReader;\nusing ::apollo::cyber::record::RecordWriter;\nusing ::apollo::cyber::record::RecordMessage;\nusing apollo::cyber::message::RawMessage;\n\nconst char CHANNEL_NAME_1[] = \n/test/channel1\n;\nconst char CHANNEL_NAME_2[] = \n/test/channel2\n;\nconst char MESSAGE_TYPE_1[] = \napollo.cyber.proto.Test\n;\nconst char MESSAGE_TYPE_2[] = \napollo.cyber.proto.Channel\n;\nconst char PROTO_DESC[] = \n1234567890\n;\nconst char STR_10B[] = \n1234567890\n;\nconst char TEST_FILE[] = \ntest.record\n;\n\nvoid test_write(const std::string \nwritefile) {\n  RecordWriter writer;\n  writer.SetSizeOfFileSegmentation(0);\n  writer.SetIntervalOfFileSegmentation(0);\n  writer.Open(writefile);\n  writer.WriteChannel(CHANNEL_NAME_1, MESSAGE_TYPE_1, PROTO_DESC);\n  for (uint32_t i = 0; i \n 100; ++i) {\n    auto msg = std::make_shared\nRawMessage\n(\nabc\n + std::to_string(i));\n    writer.WriteMessage(CHANNEL_NAME_1, msg, 888 + i); \n  }\n  writer.Close();\n}\n\nvoid test_read(const std::string \nreadfile) {\n  RecordReader reader(readfile);\n  RecordMessage message;\n  uint64_t msg_count = reader.GetMessageNumber(CHANNEL_NAME_1);\n  AINFO \n \nMSGTYPE: \n \n reader.GetMessageType(CHANNEL_NAME_1);\n  AINFO \n \nMSGDESC: \n \n reader.GetProtoDesc(CHANNEL_NAME_1);\n\n  // read all message\n  uint64_t i = 0;\n  uint64_t valid = 0;\n  for (i = 0; i \n msg_count; ++i) {\n    if (reader.ReadMessage(\nmessage)) {\n      AINFO \n \nmsg[\n \n i \n \n]-\n \n\n            \n \nchannel name: \n \n message.channel_name\n            \n \n; content: \n \n message.content\n            \n \n; msg time: \n \n message.time;\n      valid++;\n    } else {\n      AERROR \n \nread msg[\n \n i \n \n] failed\n;\n    }\n  }\n  AINFO \n \nstatic msg=================\n;\n  AINFO \n \nMSG validmsg:totalcount: \n \n valid \n \n:\n \n msg_count;\n}\n\nint main(int argc, char *argv[]) {\n  apollo::cyber::Init(argv[0]);\n  test_write(TEST_FILE);\n  sleep(1);\n  test_read(TEST_FILE);\n  return 0;\n}\n\n\n\n\nBuild and run\n\n\n\n\nBuild: bazel build cyber/examples/\u2026\n\n\nRun: ./bazel-bin/cyber/examples/record\n\n\nExamining result:\n\n\n\n\nI1124 16:56:27.248200 15118 record.cc:64] [record] msg[0]-\n channel name: /test/channel1; content: abc0; msg time: 888\nI1124 16:56:27.248227 15118 record.cc:64] [record] msg[1]-\n channel name: /test/channel1; content: abc1; msg time: 889\nI1124 16:56:27.248239 15118 record.cc:64] [record] msg[2]-\n channel name: /test/channel1; content: abc2; msg time: 890\nI1124 16:56:27.248252 15118 record.cc:64] [record] msg[3]-\n channel name: /test/channel1; content: abc3; msg time: 891\nI1124 16:56:27.248297 15118 record.cc:64] [record] msg[4]-\n channel name: /test/channel1; content: abc4; msg time: 892\nI1124 16:56:27.248378 15118 record.cc:64] [record] msg[5]-\n channel name: /test/channel1; content: abc5; msg time: 893\n...\nI1124 16:56:27.250422 15118 record.cc:73] [record] static msg=================\nI1124 16:56:27.250434 15118 record.cc:74] [record] MSG validmsg:totalcount: 100:100\n\n\n\n\nAPI Directory\n\n\nNode API\n\n\nFor additional information and examples, refer to \nNode\n\n\nAPI List\n\n\n//create writer with user-define attr and message type\n  auto CreateWriter(const proto::RoleAttributes\n role_attr)\n      -\n std::shared_ptr\ntransport::Writer\nMessageT\n;\n  //create reader with user-define attr, callback and message type\n  auto CreateReader(const proto::RoleAttributes\n role_attr,\n      const croutine::CRoutineFunc\nMessageT\n reader_func)\n      -\n std::shared_ptr\ntransport::Reader\nMessageT\n;\n  //create writer with specific channel name and message type\n  auto CreateWriter(const std::string\n channel_name)\n      -\n std::shared_ptr\ntransport::Writer\nMessageT\n;\n  //create reader with specific channel name, callback and message type\n  auto CreateReader(const std::string\n channel_name,\n      const croutine::CRoutineFunc\nMessageT\n reader_func)\n      -\n std::shared_ptr\ntransport::Reader\nMessageT\n;\n  //create reader with user-define config, callback and message type\n  auto CreateReader(const ReaderConfig\n config,\n                    const CallbackFunc\nMessageT\n reader_func)\n      -\n std::shared_ptr\ncybertron::Reader\nMessageT\n;\n  //create service with name and specific callback\n  auto CreateService(const std::string\n service_name,\n      const typename service::Service\nRequest, Response\n::ServiceCallback\n service_calllback)\n      -\n std::shared_ptr\nservice::Service\nRequest, Response\n;\n  //create client with name to send request to server\n  auto CreateClient(const std::string\n service_name)\n      -\n std::shared_ptr\nservice::Client\nRequest, Response\n;\n\n\n\n\n\nWriter API\n\n\nFor additional information and examples, refer to \nWriter\n\n\nAPI List\n\n\nbool Write(const std::shared_ptr\nMessageT\n message);\n\n\n\n\nClient API\n\n\nFor additional information and examples, refer to \nClient\n\n\nAPI List\n\n\nSharedResponse SendRequest(SharedRequest request,\nconst std::chrono::seconds\n timeout_s = std::chrono::seconds(5));SharedResponse SendRequest(const Request\n request,\nconst std::chrono::seconds\n timeout_s = std::chrono::seconds(5));\n\n\n\n\nParameter API\n\n\nThe interface that the user uses to perform parameter related operations:\n\n\n\n\nSet the parameter related API.\n\n\nRead the parameter related API.\n\n\nCreate a ParameterService to provide parameter service related APIs for other nodes.\n\n\nCreate a ParameterClient that uses the parameters provided by other nodes to service related APIs.\n\n\n\n\nFor additional information and examples, refer to \nParameter\n\n\nAPI List - Setting parameters\n\n\n Parameter();  // Name is empty, type is NOT_SET\n  explicit Parameter(const Parameter\n parameter);\n  explicit Parameter(const std::string\n name);  // Type is NOT_SET\n  Parameter(const std::string\n name, const bool bool_value);  \n  Parameter(const std::string\n name, const int int_value);\n  Parameter(const std::string\n name, const int64_t int_value);\n  Parameter(const std::string\n name, const float double_value);\n  Parameter(const std::string\n name, const double double_value);\n  Parameter(const std::string\n name, const std::string\n string_value);\n  Parameter(const std::string\n name, const char* string_value);\n  Parameter(const std::string\n name, const std::string\n msg_str,\n            const std::string\n full_name, const std::string\n proto_desc);\n  Parameter(const std::string\n name, const google::protobuf::Message\n msg);\n\n\n\n\nAPI List - Reading parameters\n\n\n  inline ParamType type() const;\n  inline std::string TypeName() const;\n  inline std::string Descriptor() const;\n  inline const std::string Name() const;\n  inline bool AsBool() const;\n  inline int64_t AsInt64() const;\n  inline double AsDouble() const;\n  inline const std::string AsString() const;\n  std::string DebugString() const;\n  template \ntypename Type\n\n  typename std::enable_if\nstd::is_base_of\ngoogle::protobuf::Message, Type\n::value, Type\n::type\n  value() const;\n  template \ntypename Type\n\n  typename std::enable_if\nstd::is_integral\nType\n::value \n !std::is_same\nType, bool\n::value, Type\n::type\n  value() const;\n  template \ntypename Type\n\n  typename std::enable_if\nstd::is_floating_point\nType\n::value, Type\n::type\n  value() const;\n  template \ntypename Type\n\n  typename std::enable_if\nstd::is_convertible\nType, std::string\n::value, const std::string\n::type\n  value() const;\n  template \ntypename Type\n\n  typename std::enable_if\nstd::is_same\nType, bool\n::value, bool\n::type \n  value() const;\n\n\n\n\nAPI List - Creating parameter service\n\n\n  explicit ParameterService(const std::shared_ptr\nNode\n node);\n  void SetParameter(const Parameter\n parameter);\n  bool GetParameter(const std::string\n param_name, Parameter* parameter);\n  bool ListParameters(std::vector\nParameter\n* parameters);\n\n\n\n\n\nAPI List - Creating parameter client\n\n\n ParameterClient(const std::shared_ptr\nNode\n node, const std::string\n service_node_name);\n  bool SetParameter(const Parameter\n parameter);\n  bool GetParameter(const std::string\n param_name, Parameter* parameter);\n  bool ListParameters(std::vector\nParameter\n* parameters);\n\n\n\n\nTimer API\n\n\nYou can set the parameters of the Timer and call the start and stop interfaces to start the timer and stop the timer.\nFor additional information and examples, refer to \nTimer\n\n\nAPI List\n\n\n Timer(uint32_t period, std::function\nvoid()\n callback, bool oneshot);\n  Timer(TimerOption opt);\n  void SetTimerOption(TimerOption opt);\n  void Start();\n  void Stop();\n  ```\n\n## Time API\nFor additional information and examples, refer to [Time](#use-of-time)\n\n### API List\n\n```C \n  static const Time MAX;\n  static const Time MIN;\n  Time() {}\n  explicit Time(uint64_t nanoseconds);\n  explicit Time(int nanoseconds);\n  explicit Time(double seconds);\n  Time(uint32_t seconds, uint32_t nanoseconds);\n  Time(const Time\n other);\n  static Time Now();\n  static Time MonoTime();\n  static void SleepUntil(const Time\n time);\n  double ToSecond() const;\n  uint64_t ToNanosecond() const;\n  std::string ToString() const;\n  bool IsZero() const;\n\n\n\n\nDuration API\n\n\nInterval-related interface, used to indicate the time interval, can be initialized according to the specified nanosecond or second.\n\n\nAPI List\n\n\n  Duration() {}\n  Duration(int64_t nanoseconds);\n  Duration(int nanoseconds);\n  Duration(double seconds);\n  Duration(uint32_t seconds, uint32_t nanoseconds);\n  Duration(const Rate\n rate);\n  Duration(const Duration\n other);\n  double ToSecond() const;\n  int64_t ToNanosecond() const;\n  bool IsZero() const;\n  void Sleep() const;\n  ```\n\n## Rate API\nThe frequency interface is generally used to initialize the time of the sleep frequency after the object is initialized according to the specified frequency.\n\n### API List\n\n```C \n  Rate(double frequency);\n  Rate(uint64_t nanoseconds);\n  Rate(const Duration\n);\n  void Sleep();\n  void Reset();\n  Duration CycleTime() const;\n  Duration ExpectedCycleTime() const { return expected_cycle_time_; }\n\n\n\n\nRecordReader API\n\n\nThe interface for reading the record file is used to read the message and channel information in the record file.\n\n\nAPI List\n\n\nC \n  RecordReader();\n  bool Open(const std::string\n filename, uint64_t begin_time = 0,\n            uint64_t end_time = UINT64_MAX);\n  void Close();\n  bool ReadMessage();\n  bool EndOfFile();\n  const std::string\n CurrentMessageChannelName();\n  std::shared_ptr\nRawMessage\n CurrentRawMessage();\n  uint64_t CurrentMessageTime();\n\n\nRecordWriter API\n\n\nThe interface for writing the record file, used to record the message and channel information into the record file.\n\n\nAPI List\n\n\nC \n RecordWriter();\n  bool Open(const std::string\n file);\n  void Close();\n  bool WriteChannel(const std::string\n name, const std::string\n type,\n                    const std::string\n proto_desc);\n  template \ntypename MessageT\n\n  bool WriteMessage(const std::string\n channel_name, const MessageT\n message,\n                    const uint64_t time_nanosec,\n                    const std::string\n proto_desc = \"\");\n  bool SetSizeOfFileSegmentation(uint64_t size_kilobytes);\n  bool SetIntervalOfFileSegmentation(uint64_t time_sec);", 
            "title": "Cyber RT API for Developers"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#cyber-rt-api-for-developers", 
            "text": "This document provides an extensive technical deep dive into how to create, manipulate and use Cyber RT's API.", 
            "title": "Cyber RT API for Developers"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#table-of-contents", 
            "text": "Talker-Listener  Service Creation and Use  Param parameter service  Log API  Building a module based on Component  Launch  Timer  Time API  Record file: Read and Write  C++ API Directory  Node  Writer  Client  Parameter  Timer  Time  Duration  Rate  RecordReader  RecordWriter", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#talker-listener", 
            "text": "The first part of demonstrating CyberRT API is to understand the Talker/Listener example. Following are three essential concepts: node (basic unit), reader(facility to read message) and writer(facility to write message) of the example.", 
            "title": "Talker-Listener"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#create-a-node", 
            "text": "In the CyberRT framework, the node is the most fundamental unit, similar to the role of a  handle . When creating a specific functional object (writer, reader, etc.), you need to create it based on an existing node instance.\nThe node creation interface is as follows:  std::unique_ptr Node  apollo::cyber::CreateNode(const std::string  node_name, const std::string  name_space =  );   Parameters:  node_name: name of the node, globally unique identifier  name_space: name of the space where the node is located  name_space is empty by default. It is the name of the space concatenated with node_name. The format is /namespace/node_name    Return value - An exclusive smart pointer to Node  Error Conditions - when  cyber::Init()  has not called, the system is in an uninitialized state, unable to create a node, return nullptr", 
            "title": "Create a node"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#create-a-writer", 
            "text": "The writer is the basic facility used in CyberRT to send messages. Every writer corresponds to a channel with a specific data type.\nThe writer is created by the  CreateWriter  interface in the node class. The interfaces are listed as below:  template  typename MessageT \n   auto CreateWriter(const std::string  channel_name)\n       -  std::shared_ptr Writer MessageT ;\ntemplate  typename MessageT \n   auto CreateWriter(const proto::RoleAttributes  role_attr)\n       -  std::shared_ptr Writer MessageT ;   Parameters:  channel_name: the name of the channel to write to  MessageT: The type of message to be written out    Return value - Shared pointer to the Writer object", 
            "title": "Create a writer"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#create-a-reader", 
            "text": "The reader is the basic facility used in cyber to receive messages. Reader has to be bound to a callback function when it is created. When a new message arrives in the channel, the callback will be called.\nThe reader is created by the  CreateReader  interface of the node class. The interfaces are listed as below:     template  typename MessageT \n   auto CreateReader(const std::string  channel_name, const std::function void(const std::shared_ptr MessageT )  reader_func)\n       -  std::shared_ptr Reader MessageT ;\n\n   template  typename MessageT \n   auto CreateReader(const ReaderConfig  config,\n                     const CallbackFunc MessageT  reader_func = nullptr)\n       -  std::shared_ptr cyber::Reader MessageT ;\n\n   template  typename MessageT \n   auto CreateReader(const proto::RoleAttributes  role_attr,\n                     const CallbackFunc MessageT  reader_func = nullptr)\n   -  std::shared_ptr cyber::Reader MessageT ;    Parameters:   MessageT: The type of message to read  channel_name: the name of the channel to receive from  reader_func: callback function to process the messages     Return value - Shared pointer to the Reader object", 
            "title": "Create a reader"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#code-example", 
            "text": "", 
            "title": "Code Example"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#talker-cyberexamplestalkercc", 
            "text": "#include  cyber/cyber.h \n#include  cyber/proto/chatter.pb.h \n#include  cyber/time/rate.h \n#include  cyber/time/time.h \nusing apollo::cyber::Rate;\nusing apollo::cyber::Time;\nusing apollo::cyber::proto::Chatter;\nint main(int argc, char *argv[]) {\n  // init cyber framework\n  apollo::cyber::Init(argv[0]);\n  // create talker node\n  std::shared_ptr apollo::cyber::Node  talker_node(\n      apollo::cyber::CreateNode( talker ));\n  // create talker\n  auto talker = talker_node- CreateWriter Chatter ( channel/chatter );\n  Rate rate(1.0);\n  while (apollo::cyber::OK()) {\n    static uint64_t seq = 0;\n    auto msg = std::make_shared apollo::cyber::proto::Chatter ();\n    msg- set_timestamp(Time::Now().ToNanosecond());\n    msg- set_lidar_timestamp(Time::Now().ToNanosecond());\n    msg- set_seq(seq++);\n    msg- set_content( Hello, apollo! );\n    talker- Write(msg);\n    AINFO    talker sent a message! ;\n    rate.Sleep();\n  }\n  return 0;\n}", 
            "title": "Talker (cyber/examples/talker.cc)"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#listener-cyberexampleslistenercc", 
            "text": "#include  cyber/cyber.h \n#include  cyber/proto/chatter.pb.h \nvoid MessageCallback(\n    const std::shared_ptr apollo::cyber::proto::Chatter  msg) {\n  AINFO    Received message seq-      msg- seq();\n  AINFO    msgcontent-    msg- content();\n}\nint main(int argc, char *argv[]) {\n  // init cyber framework\n  apollo::cyber::Init(argv[0]);  \n  // create listener node\n  auto listener_node = apollo::cyber::CreateNode( listener );\n  // create listener\n  auto listener =\n      listener_node- CreateReader apollo::cyber::proto::Chatter (\n           channel/chatter , MessageCallback);\n  apollo::cyber::WaitForShutdown();\n  return 0;\n}", 
            "title": "Listener (cyber/examples/listener.cc)"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#bazel-build-filecybersamplesbuild", 
            "text": "cc_binary(\n    name =  talker ,\n    srcs = [  talker.cc , ],\n    deps = [\n         //cyber ,\n         //cyber/examples/proto:examples_cc_proto ,\n    ],\n)\n\ncc_binary(\n    name =  listener ,\n    srcs = [  listener.cc , ],\n    deps = [\n         //cyber ,\n         //cyber/examples/proto:examples_cc_proto ,\n    ],\n)", 
            "title": "Bazel BUILD file(cyber/samples/BUILD)"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#build-and-run", 
            "text": "Build: bazel build cyber/examples/\u2026  Run talker/listener in different terminals:     ./bazel-bin/cyber/examples/talker  ./bazel-bin/cyber/examples/listener    Examine the results: you should see message printing out on listener.", 
            "title": "Build and Run"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#service-creation-and-use", 
            "text": "", 
            "title": "Service Creation and Use"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#introduction", 
            "text": "In an autonomous driving system, there are many scenarios that require more from module communication than just sending or receiving messages. Service is another way of communication between nodes. Unlike channel, service implements  two-way  communication, e.g. a node obtains a response by sending a request. This section introduces the  service  module in CyberRT API with examples.", 
            "title": "Introduction"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#demo-example", 
            "text": "Problem: create a client-server model that pass Driver.proto back and forth.\nWhen a request is sent in by the client, the server parses/processes the request and returns the response.  The implementation of the demo mainly includes the following steps.", 
            "title": "Demo - Example"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#define-request-and-response-messages", 
            "text": "All messages in cyber are in the  protobuf  format. Any protobuf message with serialize/deserialize interfaces can be used as the service request and response message.  Driver  in examples.proto is used as service request and response in this example:  // filename: examples.proto\nsyntax =  proto2 ;\npackage apollo.cyber.examples.proto;\nmessage Driver {\n    optional string content = 1;\n    optional uint64 msg_id = 2;\n    optional uint64 timestamp = 3;\n};", 
            "title": "Define request and response messages"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#create-a-service-and-a-client", 
            "text": "// filename: cyber/examples/service.cc\n#include  cyber/cyber.h \n#include  cyber/examples/proto/examples.pb.h \n\nusing apollo::cyber::examples::proto::Driver;\n\nint main(int argc, char* argv[]) {\n  apollo::cyber::Init(argv[0]);\n  std::shared_ptr apollo::cyber::Node  node(\n      apollo::cyber::CreateNode( start_node ));\n  auto server = node- CreateService Driver, Driver (\n       test_server , [](const std::shared_ptr Driver  request,\n                        std::shared_ptr Driver  response) {\n        AINFO    server: I am driver server ;\n        static uint64_t id = 0;\n        ++id;\n        response- set_msg_id(id);\n        response- set_timestamp(0);\n      }); \n  auto client = node- CreateClient Driver, Driver ( test_server );\n  auto driver_msg = std::make_shared Driver ();\n  driver_msg- set_msg_id(0);\n  driver_msg- set_timestamp(0);\n  while (apollo::cyber::OK()) {\n    auto res = client- SendRequest(driver_msg);\n    if (res != nullptr) {\n      AINFO    client: responese:     res- ShortDebugString();\n    } else {\n      AINFO    client: service may not ready. ;\n    }   \n    sleep(1);\n  }\n\n  apollo::cyber::WaitForShutdown();\n  return 0;\n}", 
            "title": "Create a service and a client"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#bazel-build-file", 
            "text": "cc_binary(\n    name =  service ,\n    srcs = [  service.cc , ],\n    deps = [\n         //cyber ,\n         //cyber/examples/proto:examples_cc_proto ,\n    ],\n)", 
            "title": "Bazel build file"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#build-and-run_1", 
            "text": "Build service/client: bazel build cyber/examples/\u2026  Run: ./bazel-bin/cyber/examples/service  Examining result: you should see content below in apollo/data/log/service.INFO    I1124 16:36:44.568845 14965 service.cc:30] [service] server: i am driver server\nI1124 16:36:44.569031 14949 service.cc:43] [service] client: responese: msg_id: 1 timestamp: 0\nI1124 16:36:45.569514 14966 service.cc:30] [service] server: i am driver server\nI1124 16:36:45.569932 14949 service.cc:43] [service] client: responese: msg_id: 2 timestamp: 0\nI1124 16:36:46.570627 14967 service.cc:30] [service] server: i am driver server\nI1124 16:36:46.571024 14949 service.cc:43] [service] client: responese: msg_id: 3 timestamp: 0\nI1124 16:36:47.571566 14968 service.cc:30] [service] server: i am driver server\nI1124 16:36:47.571962 14949 service.cc:43] [service] client: responese: msg_id: 4 timestamp: 0\nI1124 16:36:48.572634 14969 service.cc:30] [service] server: i am driver server\nI1124 16:36:48.573030 14949 service.cc:43] [service] client: responese: msg_id: 5 timestamp: 0", 
            "title": "Build and run"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#precautions", 
            "text": "When registering a service, note that duplicate service names are not allowed  The node name applied when registering the server and client should not be duplicated either", 
            "title": "Precautions"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#parameter-service", 
            "text": "The Parameter Service is used for shared data between nodes, and provides basic operations such as  set ,  get , and  list . The Parameter Service is based on the  Service  implementation and contains service and client.", 
            "title": "Parameter Service"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#parameter-object", 
            "text": "", 
            "title": "Parameter Object"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#supported-data-types", 
            "text": "All parameters passed through cyber are  apollo::cyber::Parameter  objects, the table below lists the 5 supported parameter types.       Parameter type  C++ data type  protobuf data type      apollo::cyber::proto::ParamType::INT  int64_t  int64    apollo::cyber::proto::ParamType::DOUBLE  double  double    apollo::cyber::proto::ParamType::BOOL  bool  bool    apollo::cyber::proto::ParamType::STRING  std::string  string    apollo::cyber::proto::ParamType::PROTOBUF  std::string  string    apollo::cyber::proto::ParamType::NOT_SET  -  -     Besides the 5 types above, Parameter also supports interface with protobuf object as incoming parameter. Post performing serialization processes the object and converts it to the STRING type for transfer.", 
            "title": "Supported Data types"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#creating-the-parameter-object", 
            "text": "Supported constructors:    Parameter();  // Name is empty, type is NOT_SET\n  explicit Parameter(const Parameter  parameter);\n  explicit Parameter(const std::string  name);  // type\u4e3aNOT_SET\n  Parameter(const std::string  name, const bool bool_value);  \n  Parameter(const std::string  name, const int int_value);\n  Parameter(const std::string  name, const int64_t int_value);\n  Parameter(const std::string  name, const float double_value);\n  Parameter(const std::string  name, const double double_value);\n  Parameter(const std::string  name, const std::string  string_value);\n  Parameter(const std::string  name, const char* string_value);\n  Parameter(const std::string  name, const std::string  msg_str,\n            const std::string  full_name, const std::string  proto_desc);\n  Parameter(const std::string  name, const google::protobuf::Message  msg);  Sample code of using Parameter object:  C\n  Parameter a(\"int\", 10);\n  Parameter b(\"bool\", true);\n  Parameter c(\"double\", 0.1);\n  Parameter d(\"string\", \"cyber\");\n  Parameter e(\"string\", std::string(\"cyber\"));\n  // proto message Chatter\n  Chatter chatter;\n  Parameter f(\"chatter\", chatter);\n  std::string msg_str(\"\");\n  chatter.SerializeToString( msg_str);\n  std::string msg_desc(\"\");\n  ProtobufFactory::GetDescriptorString(chatter,  msg_desc);\n  Parameter g(\"chatter\", msg_str, Chatter::descriptor()- full_name(), msg_desc);", 
            "title": "Creating the Parameter Object"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#interface-and-data-reading", 
            "text": "Interface list:    inline ParamType type() const;\n  inline std::string TypeName() const;\n  inline std::string Descriptor() const;\n  inline const std::string Name() const;\n  inline bool AsBool() const;\n  inline int64_t AsInt64() const;\n  inline double AsDouble() const;\n  inline const std::string AsString() const;\n  std::string DebugString() const;\n  template  typename Type \n  typename std::enable_if std::is_base_of google::protobuf::Message, Type ::value, Type ::type\n  value() const;\n  template  typename Type \n  typename std::enable_if std::is_integral Type ::value   !std::is_same Type, bool ::value, Type ::type\n  value() const;\n  template  typename Type \n  typename std::enable_if std::is_floating_point Type ::value, Type ::type\n  value() const;\n  template  typename Type \n  typename std::enable_if std::is_convertible Type, std::string ::value, const std::string ::type\n  value() const;\n  template  typename Type \n  typename std::enable_if std::is_same Type, bool ::value, bool ::type \n  value() const;  An example of how to use those interfaces:    Parameter a( int , 10);\n  a.Name();  // return int\n  a.Type();  // return apollo::cyber::proto::ParamType::INT\n  a.TypeName();  // return string: INT\n  a.DebugString();  // return string: {name:  int , type:  INT , value: 10}\n  int x = a.AsInt64();  // x = 10\n  x = a.value int64_t ();  // x = 10\n  x = a.AsString();  // Undefined behavior, error log prompt\n  f.TypeName();  // return string: chatter\n  auto chatter = f.value Chatter ();", 
            "title": "Interface and Data Reading"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#parameter-service_1", 
            "text": "If a node wants to provide a Parameter Service to other nodes, then you need to create a  ParameterService .  /**\n   * @brief Construct a new ParameterService object\n   * \n   * @param node shared_ptr of the node handler\n   */\n  explicit ParameterService(const std::shared_ptr Node  node);  Since all parameters are stored in the parameter service object, the parameters can be manipulated directly in the ParameterService without sending a service request.  Setting parameters:   /**\n  * @brief Set the Parameter object\n  *\n  * @param parameter parameter to be set\n  */\n  void SetParameter(const Parameter  parameter);  Getting parameters:    /**\n   * @brief Get the Parameter object\n   * \n   * @param param_name \n   * @param parameter the pointer to store \n   * @return true \n   * @return false call service fail or timeout\n   */\n  bool GetParameter(const std::string  param_name, Parameter* parameter);  Getting the list of parameters:   /**\n   * @brief Get all the Parameter objects\n   *\n   * @param parameters pointer of vector to store all the parameters\n   * @return true\n   * @return false call service fail or timeout\n   */\n  bool ListParameters(std::vector Parameter * parameters);", 
            "title": "Parameter Service"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#parameter-client", 
            "text": "If a node wants to use parameter services of other nodes, you need to create a  ParameterClient .  /**\n   * @brief Construct a new ParameterClient object\n   *\n   * @param node shared_ptr of the node handler\n   * @param service_node_name node name which provide a param services\n   */\n  ParameterClient(const std::shared_ptr Node  node, const std::string  service_node_name);  You could also perform  SetParameter ,  GetParameter  and  ListParameters  mentioned under  Parameter Service .", 
            "title": "Parameter Client"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#demo-example_1", 
            "text": "#include  cyber/cyber.h \n#include  cyber/parameter/parameter_client.h \n#include  cyber/parameter/parameter_server.h \n\nusing apollo::cyber::Parameter;\nusing apollo::cyber::ParameterServer;\nusing apollo::cyber::ParameterClient;\n\nint main(int argc, char** argv) {\n  apollo::cyber::Init(*argv);\n  std::shared_ptr apollo::cyber::Node  node =\n      apollo::cyber::CreateNode( parameter );\n  auto param_server = std::make_shared ParameterServer (node);\n  auto param_client = std::make_shared ParameterClient (node,  parameter );\n  param_server- SetParameter(Parameter( int , 1));\n  Parameter parameter;\n  param_server- GetParameter( int ,  parameter);\n  AINFO    int:     parameter.AsInt64();\n  param_client- SetParameter(Parameter( string ,  test ));\n  param_client- GetParameter( string ,  parameter);\n  AINFO    string:     parameter.AsString();\n  param_client- GetParameter( int ,  parameter);\n  AINFO    int:     parameter.AsInt64();\n  return 0;\n}", 
            "title": "Demo - example"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#build-and-run_2", 
            "text": "Build: bazel build cyber/examples/\u2026  Run: ./bazel-bin/cyber/examples/paramserver", 
            "title": "Build and run"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#log-api", 
            "text": "", 
            "title": "Log API"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#log-library", 
            "text": "Cyber log library is built on top of glog. The following header files need to be included:  #include  cyber/common/log.h \n#include  cyber/init.h", 
            "title": "Log library"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#log-configuration", 
            "text": "Default global config path: cyber/setup.bash  The configs below could be modified by devloper:  export GLOG_log_dir=/apollo/data/log\nexport GLOG_alsologtostderr=0\nexport GLOG_colorlogtostderr=1\nexport GLOG_minloglevel=0", 
            "title": "Log configuration"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#log-initialization", 
            "text": "Call the Init method at the code entry to initialize the log:  apollo::cyber::cyber::Init(argv[0]) is initialized. \nIf no macro definition is made in the previous component, the corresponding log is printed to the binary log.", 
            "title": "Log initialization"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#log-output-macro", 
            "text": "Log library is encapsulated in Log printing macros. The related log macros are used as follows:  ADEBUG    hello cyber. ;\nAINFO     hello cyber. ;\nAWARN     hello cyber. ;\nAERROR    hello cyber. ;\nAFATAL    hello cyber. ;", 
            "title": "Log output macro"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#log-format", 
            "text": "The format is  MODULE_NAME .log. LOG_LEVEL . datetime . process_id", 
            "title": "Log format"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#about-log-files", 
            "text": "Currently, the only different output behavior from default glog is that different log levels of a module will be written into the same log file.", 
            "title": "About log files"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#building-a-module-based-on-component", 
            "text": "", 
            "title": "Building a module based on Component"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#key-concepts", 
            "text": "", 
            "title": "Key concepts"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#1-component", 
            "text": "The component is the base class that Cyber-RT provides to build application modules. Each specific application module can inherit the Component class and define its own  Init  and  Proc  functions so that it can be loaded into the Cyber framework.", 
            "title": "1. Component"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#2-binary-vs-component", 
            "text": "There are two options to use Cyber-RT framework for applications:   Binary based: the application is compiled separately into a binary, which communicates with other cyber modules by creating its own  Reader  and  Writer .  Component based: the application is compiled into a Shared Library. By inheriting the Component class and writing the corresponding dag description file, the Cyber-RT framework will load and run the application dynamically.", 
            "title": "2. Binary vs Component"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#the-essential-component-interface", 
            "text": "The component's  Init()  function is like the main function that does some initialization of the algorithm.  Component's  Proc()  function works like Reader's callback function that is called by the framework when a message arrives.", 
            "title": "The essential Component interface"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#advantages-of-using-component", 
            "text": "Component can be loaded into different processes through the launch file, and the deployment is flexible.  Component can change the received channel name by modifying the dag file without recompiling.  Component supports receiving multiple types of data.  Component supports providing multiple fusion strategies.", 
            "title": "Advantages of using Component"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#3-dag-file-format", 
            "text": "An example dag file:    # Define all coms in DAG streaming.\n    module_config {\n    module_library :  lib/libperception_component.so \n    components {\n        class_name :  PerceptionComponent \n        config {\n            name :  perception \n            readers {\n                channel:  perception/channel_name \n            }\n        }\n    }\n    timer_components {\n        class_name :  DriverComponent \n        config {\n            name :  driver \n            interval : 100\n        }\n    }\n    }   module_library : If you want to load the .so library the root directory is the working directory of cyber (the same directory of  setup.bash )  components   timer_component : Select the base component class type that needs to be loaded.  class_name : the name of the component class to load  name : the loaded class_name as the identifier of the loading example  readers : Data received by the current component, supporting 1-3 channels of data.", 
            "title": "3. Dag file format"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#demo-examples", 
            "text": "", 
            "title": "Demo - examples"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#common_component_examplecyberexamplescommon_component_example", 
            "text": "Header definition(common_component_example.h)  #include  memory \n\n#include  cyber/class_loader/class_loader.h \n#include  cyber/component/component.h \n#include  cyber/examples/proto/examples.pb.h \n\nusing apollo::cyber::examples::proto::Driver;\nusing apollo::cyber::Component;\nusing apollo::cyber::ComponentBase;\n\nclass Commontestcomponent : public Component Driver, Driver  {\n public:\n  bool Init() override;\n  bool Proc(const std::shared_ptr Driver  msg0,\n            const std::shared_ptr Driver  msg1) override;\n};\nCYBER_REGISTER_COMPONENT(Commontestcomponent)  Cpp file implementation(common_component_example.cc)  #include  cyber/examples/common_component_smaple/common_component_example.h \n\n#include  cyber/class_loader/class_loader.h \n#include  cyber/component/component.h \n\nbool Commontestcomponent::Init() {\n  AINFO    Commontest component init ;\n  return true;\n}\n\nbool Commontestcomponent::Proc(const std::shared_ptr Driver  msg0,\n                               const std::shared_ptr Driver  msg1) {\n  AINFO    Start commontest component Proc [    msg0- msg_id()    ] [ \n          msg1- msg_id()    ] ;\n  return true;\n}", 
            "title": "Common_component_example(cyber/examples/common_component_example/*)"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#timer_component_examplecyberexamplestimer_component_example", 
            "text": "Header definition(timer_component_example.h)  #include  memory \n\n#include  cyber/class_loader/class_loader.h \n#include  cyber/component/component.h \n#include  cyber/component/timer_component.h \n#include  cyber/examples/proto/examples.pb.h \n\nusing apollo::cyber::examples::proto::Driver;\nusing apollo::cyber::Component;\nusing apollo::cyber::ComponentBase;\nusing apollo::cyber::TimerComponent;\nusing apollo::cyber::Writer;\n\nclass TimertestComponent : public TimerComponent {\n public:\n  bool Init() override;\n  bool Proc() override;\n\n private:\n  std::shared_ptr Writer Driver  driver_writer_ = nullptr;\n};\nCYBER_REGISTER_COMPONENT(TimertestComponent)  Cpp file implementation(timer_component_example.cc)  #include  cyber/examples/timer_component_example/timer_component_example.h \n\n#include  cyber/class_loader/class_loader.h \n#include  cyber/component/component.h \n#include  cyber/examples/proto/examples.pb.h \n\nbool TimertestComponent::Init() {\n  driver_writer_ = node_- CreateWriter Driver ( /carstatus/channel );\n  return true;\n}\n\nbool TimertestComponent::Proc() {\n  static int i = 0;\n  auto out_msg = std::make_shared Driver ();\n  out_msg- set_msg_id(i++);\n  driver_writer_- Write(out_msg);\n  AINFO    timertestcomponent: Write drivermsg- \n          out_msg- ShortDebugString();\n  return true;\n}", 
            "title": "Timer_component_example(cyber/examples/timer_component_example/*)"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#build-and-run_3", 
            "text": "Use timertestcomponent as example:   Build: bazel build cyber/examples/timer_component_smaple/\u2026  Run: mainboard -d cyber/examples/timer_component_smaple/timer.dag", 
            "title": "Build and run"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#precautions_1", 
            "text": "Component needs to be registered to load the class through SharedLibrary. The registration interface looks like:   CYBER_REGISTER_CLASS(DriverComponent)  If you use a namespace when registering, you also need to add a namespace when you define it in the dag file.   The configuration files of the Component and TimerComponent are different, please be careful not to mix the two up.", 
            "title": "Precautions"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#launch", 
            "text": "cyber_launch  is the launcher of the Cyber-RT framework. It starts multiple mainboards according to the launch file, and loads different components into different mainboards according to the dag file.\ncyber_launch supports two scenarios for dynamically loading components or starting Binary programs in a child process.", 
            "title": "Launch"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#launch-file-format", 
            "text": "cyber \n     module \n         name driver /name \n         dag_conf driver.dag /dag_conf \n         process_name /process_name \n         exception_handler exit /exception_handler \n     /module \n     module \n         name perception /name \n         dag_conf perception.dag /dag_conf \n         process_name /process_name \n         exception_handler respawn /exception_handler \n     /module \n     module \n         name planning /name \n         dag_conf planning.dag /dag_conf \n         process_name /process_name \n     /module  /cyber   Module :\nEach loaded component or binary is a module   name  is the loaded module name  dag_conf  is the name of the corresponding dag file of the component  process_name  is the name of the mainboard process once started, and the same component of process_name will be loaded and run in the same process.  exception_handler  is the handler method when the exception occurs in the process. The value can be exit or respawn listed below.  exit, which means that the entire process needs to stop running when the current process exits abnormally.   respawn, the current process needs to be restarted after abnormal exit. Start this process. If there is no such thing as it is empty, it means no treatment. Can be controlled by the user according to the specific conditions of the process", 
            "title": "Launch File Format"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#timer", 
            "text": "Timer can be used to create a timed task to run on a periodic basis, or to run only once", 
            "title": "Timer"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#timer-interface", 
            "text": "/**\n   * @brief Construct a new Timer object\n   *\n   * @param period The period of the timer, unit is ms\n   * @param callback The tasks that the timer needs to perform\n   * @param oneshot True: perform the callback only after the first timing cycle\n   *                False: perform the callback every timed period\n   */\n  Timer(uint32_t period, std::function void()  callback, bool oneshot);  Or you could encapsulate the parameters into a timer option as follows:  struct TimerOption {\n  uint32_t period;                 // The period of the timer, unit is ms\n  std::function void()  callback;  // The tasks that the timer needs to perform\n  bool oneshot;  // True: perform the callback only after the first timing cycle\n                 // False: perform the callback every timed period\n};\n/**\n   * @brief Construct a new Timer object\n   * \n   * @param opt Timer option\n   */\n  explicit Timer(TimerOption opt);", 
            "title": "Timer Interface"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#start-timer", 
            "text": "After creating a Timer instance, you must call  Timer::Start()  to start the timer.", 
            "title": "Start Timer"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#stop-timer", 
            "text": "When you need to manually stop a timer that has already started, you can call the  Timer::Stop()  interface.", 
            "title": "Stop Timer"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#demo-example_2", 
            "text": "#include  iostream \n#include  cyber/cyber.h \nint main(int argc, char** argv) {\n    cyber::Init(argv[0]);\n    // Print current time every 100ms\n    cyber::Timer timer(100, [](){\n        std::cout   cyber::Time::Now()   std::endl;\n    }, false);\n    timer.Start()\n    sleep(1);\n    timer.Stop();\n}", 
            "title": "Demo - example"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#time-api", 
            "text": "Time is a class used to manage time; it can be used for current time acquisition, time-consuming calculation, time conversion, and so on.  The time interfaces are as follows:  // constructor, passing in a different value to construct Time\nTime(uint64_t nanoseconds); //uint64_t, in nanoseconds\nTime(int nanoseconds); // int type, unit: nanoseconds\nTime(double seconds); // double, in seconds\nTime(uint32_t seconds, uint32_t nanoseconds); \n// seconds seconds + nanoseconds nanoseconds\nStatic Time Now(); // Get the current time\nDouble ToSecond() const; // convert to seconds\nUint64_t ToNanosecond() const; // Convert to nanoseconds\nStd::string ToString() const; // Convert to a string in the format  2018-07-10 20:21:51.123456789 \nBool IsZero() const; // Determine if the time is 0  A code example can be seen below:  #include  iostream \n#include  cyber/cyber.h \n#include  cyber/duration.h \nint main(int argc, char** argv) {\n    cyber::Init(argv[0]);\n    Time t1(1531225311123456789UL);\n    std::cout   t1.ToString() std::endl; // 2018-07-10 20:21:51.123456789\n    // Duration time interval\n    Time t1(100);\n    Duration d(200);\n    Time t2(300);\n    assert(d == (t1-t2)); // true\n}", 
            "title": "Time API"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#record-file-read-and-write", 
            "text": "", 
            "title": "Record file: Read and Write"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#reading-the-reader-file", 
            "text": "RecordReader  is the component used to read messages in the cyber framework. Each RecordReader can open an existing record file through the  Open  method, and the thread will asynchronously read the information in the record file. The user only needs to execute ReadMessage to extract the latest message in RecordReader, and then get the message information through GetCurrentMessageChannelName, GetCurrentRawMessage, GetCurrentMessageTime.  RecordWriter  is the component used to record messages in the cyber framework. Each RecordWriter can create a new record file through the Open method. The user only needs to execute WriteMessage and WriteChannel to write message and channel information, and the writing process is asynchronous.", 
            "title": "Reading the Reader file"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#demo-examplecyberexamplesrecordcc", 
            "text": "Write 100 RawMessage to TEST_FILE  through  test_write  method, then read them out through  test_read  method.  #include  string \n\n#include  cyber/cyber.h \n#include  cyber/message/raw_message.h \n#include  cyber/proto/record.pb.h \n#include  cyber/record/record_message.h \n#include  cyber/record/record_reader.h \n#include  cyber/record/record_writer.h \n\nusing ::apollo::cyber::record::RecordReader;\nusing ::apollo::cyber::record::RecordWriter;\nusing ::apollo::cyber::record::RecordMessage;\nusing apollo::cyber::message::RawMessage;\n\nconst char CHANNEL_NAME_1[] =  /test/channel1 ;\nconst char CHANNEL_NAME_2[] =  /test/channel2 ;\nconst char MESSAGE_TYPE_1[] =  apollo.cyber.proto.Test ;\nconst char MESSAGE_TYPE_2[] =  apollo.cyber.proto.Channel ;\nconst char PROTO_DESC[] =  1234567890 ;\nconst char STR_10B[] =  1234567890 ;\nconst char TEST_FILE[] =  test.record ;\n\nvoid test_write(const std::string  writefile) {\n  RecordWriter writer;\n  writer.SetSizeOfFileSegmentation(0);\n  writer.SetIntervalOfFileSegmentation(0);\n  writer.Open(writefile);\n  writer.WriteChannel(CHANNEL_NAME_1, MESSAGE_TYPE_1, PROTO_DESC);\n  for (uint32_t i = 0; i   100; ++i) {\n    auto msg = std::make_shared RawMessage ( abc  + std::to_string(i));\n    writer.WriteMessage(CHANNEL_NAME_1, msg, 888 + i); \n  }\n  writer.Close();\n}\n\nvoid test_read(const std::string  readfile) {\n  RecordReader reader(readfile);\n  RecordMessage message;\n  uint64_t msg_count = reader.GetMessageNumber(CHANNEL_NAME_1);\n  AINFO    MSGTYPE:     reader.GetMessageType(CHANNEL_NAME_1);\n  AINFO    MSGDESC:     reader.GetProtoDesc(CHANNEL_NAME_1);\n\n  // read all message\n  uint64_t i = 0;\n  uint64_t valid = 0;\n  for (i = 0; i   msg_count; ++i) {\n    if (reader.ReadMessage( message)) {\n      AINFO    msg[    i    ]-   \n               channel name:     message.channel_name\n               ; content:     message.content\n               ; msg time:     message.time;\n      valid++;\n    } else {\n      AERROR    read msg[    i    ] failed ;\n    }\n  }\n  AINFO    static msg================= ;\n  AINFO    MSG validmsg:totalcount:     valid    :    msg_count;\n}\n\nint main(int argc, char *argv[]) {\n  apollo::cyber::Init(argv[0]);\n  test_write(TEST_FILE);\n  sleep(1);\n  test_read(TEST_FILE);\n  return 0;\n}", 
            "title": "Demo - example(cyber/examples/record.cc)"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#build-and-run_4", 
            "text": "Build: bazel build cyber/examples/\u2026  Run: ./bazel-bin/cyber/examples/record  Examining result:   I1124 16:56:27.248200 15118 record.cc:64] [record] msg[0]-  channel name: /test/channel1; content: abc0; msg time: 888\nI1124 16:56:27.248227 15118 record.cc:64] [record] msg[1]-  channel name: /test/channel1; content: abc1; msg time: 889\nI1124 16:56:27.248239 15118 record.cc:64] [record] msg[2]-  channel name: /test/channel1; content: abc2; msg time: 890\nI1124 16:56:27.248252 15118 record.cc:64] [record] msg[3]-  channel name: /test/channel1; content: abc3; msg time: 891\nI1124 16:56:27.248297 15118 record.cc:64] [record] msg[4]-  channel name: /test/channel1; content: abc4; msg time: 892\nI1124 16:56:27.248378 15118 record.cc:64] [record] msg[5]-  channel name: /test/channel1; content: abc5; msg time: 893\n...\nI1124 16:56:27.250422 15118 record.cc:73] [record] static msg=================\nI1124 16:56:27.250434 15118 record.cc:74] [record] MSG validmsg:totalcount: 100:100", 
            "title": "Build and run"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#api-directory", 
            "text": "", 
            "title": "API Directory"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#node-api", 
            "text": "For additional information and examples, refer to  Node", 
            "title": "Node API"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#api-list", 
            "text": "//create writer with user-define attr and message type\n  auto CreateWriter(const proto::RoleAttributes  role_attr)\n      -  std::shared_ptr transport::Writer MessageT ;\n  //create reader with user-define attr, callback and message type\n  auto CreateReader(const proto::RoleAttributes  role_attr,\n      const croutine::CRoutineFunc MessageT  reader_func)\n      -  std::shared_ptr transport::Reader MessageT ;\n  //create writer with specific channel name and message type\n  auto CreateWriter(const std::string  channel_name)\n      -  std::shared_ptr transport::Writer MessageT ;\n  //create reader with specific channel name, callback and message type\n  auto CreateReader(const std::string  channel_name,\n      const croutine::CRoutineFunc MessageT  reader_func)\n      -  std::shared_ptr transport::Reader MessageT ;\n  //create reader with user-define config, callback and message type\n  auto CreateReader(const ReaderConfig  config,\n                    const CallbackFunc MessageT  reader_func)\n      -  std::shared_ptr cybertron::Reader MessageT ;\n  //create service with name and specific callback\n  auto CreateService(const std::string  service_name,\n      const typename service::Service Request, Response ::ServiceCallback  service_calllback)\n      -  std::shared_ptr service::Service Request, Response ;\n  //create client with name to send request to server\n  auto CreateClient(const std::string  service_name)\n      -  std::shared_ptr service::Client Request, Response ;", 
            "title": "API List"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#writer-api", 
            "text": "For additional information and examples, refer to  Writer", 
            "title": "Writer API"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#api-list_1", 
            "text": "bool Write(const std::shared_ptr MessageT  message);", 
            "title": "API List"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#client-api", 
            "text": "For additional information and examples, refer to  Client", 
            "title": "Client API"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#api-list_2", 
            "text": "SharedResponse SendRequest(SharedRequest request,\nconst std::chrono::seconds  timeout_s = std::chrono::seconds(5));SharedResponse SendRequest(const Request  request,\nconst std::chrono::seconds  timeout_s = std::chrono::seconds(5));", 
            "title": "API List"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#parameter-api", 
            "text": "The interface that the user uses to perform parameter related operations:   Set the parameter related API.  Read the parameter related API.  Create a ParameterService to provide parameter service related APIs for other nodes.  Create a ParameterClient that uses the parameters provided by other nodes to service related APIs.   For additional information and examples, refer to  Parameter", 
            "title": "Parameter API"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#api-list-setting-parameters", 
            "text": "Parameter();  // Name is empty, type is NOT_SET\n  explicit Parameter(const Parameter  parameter);\n  explicit Parameter(const std::string  name);  // Type is NOT_SET\n  Parameter(const std::string  name, const bool bool_value);  \n  Parameter(const std::string  name, const int int_value);\n  Parameter(const std::string  name, const int64_t int_value);\n  Parameter(const std::string  name, const float double_value);\n  Parameter(const std::string  name, const double double_value);\n  Parameter(const std::string  name, const std::string  string_value);\n  Parameter(const std::string  name, const char* string_value);\n  Parameter(const std::string  name, const std::string  msg_str,\n            const std::string  full_name, const std::string  proto_desc);\n  Parameter(const std::string  name, const google::protobuf::Message  msg);", 
            "title": "API List - Setting parameters"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#api-list-reading-parameters", 
            "text": "inline ParamType type() const;\n  inline std::string TypeName() const;\n  inline std::string Descriptor() const;\n  inline const std::string Name() const;\n  inline bool AsBool() const;\n  inline int64_t AsInt64() const;\n  inline double AsDouble() const;\n  inline const std::string AsString() const;\n  std::string DebugString() const;\n  template  typename Type \n  typename std::enable_if std::is_base_of google::protobuf::Message, Type ::value, Type ::type\n  value() const;\n  template  typename Type \n  typename std::enable_if std::is_integral Type ::value   !std::is_same Type, bool ::value, Type ::type\n  value() const;\n  template  typename Type \n  typename std::enable_if std::is_floating_point Type ::value, Type ::type\n  value() const;\n  template  typename Type \n  typename std::enable_if std::is_convertible Type, std::string ::value, const std::string ::type\n  value() const;\n  template  typename Type \n  typename std::enable_if std::is_same Type, bool ::value, bool ::type \n  value() const;", 
            "title": "API List - Reading parameters"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#api-list-creating-parameter-service", 
            "text": "explicit ParameterService(const std::shared_ptr Node  node);\n  void SetParameter(const Parameter  parameter);\n  bool GetParameter(const std::string  param_name, Parameter* parameter);\n  bool ListParameters(std::vector Parameter * parameters);", 
            "title": "API List - Creating parameter service"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#api-list-creating-parameter-client", 
            "text": "ParameterClient(const std::shared_ptr Node  node, const std::string  service_node_name);\n  bool SetParameter(const Parameter  parameter);\n  bool GetParameter(const std::string  param_name, Parameter* parameter);\n  bool ListParameters(std::vector Parameter * parameters);", 
            "title": "API List - Creating parameter client"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#timer-api", 
            "text": "You can set the parameters of the Timer and call the start and stop interfaces to start the timer and stop the timer.\nFor additional information and examples, refer to  Timer", 
            "title": "Timer API"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#api-list_3", 
            "text": "Timer(uint32_t period, std::function void()  callback, bool oneshot);\n  Timer(TimerOption opt);\n  void SetTimerOption(TimerOption opt);\n  void Start();\n  void Stop();\n  ```\n\n## Time API\nFor additional information and examples, refer to [Time](#use-of-time)\n\n### API List\n\n```C \n  static const Time MAX;\n  static const Time MIN;\n  Time() {}\n  explicit Time(uint64_t nanoseconds);\n  explicit Time(int nanoseconds);\n  explicit Time(double seconds);\n  Time(uint32_t seconds, uint32_t nanoseconds);\n  Time(const Time  other);\n  static Time Now();\n  static Time MonoTime();\n  static void SleepUntil(const Time  time);\n  double ToSecond() const;\n  uint64_t ToNanosecond() const;\n  std::string ToString() const;\n  bool IsZero() const;", 
            "title": "API List"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#duration-api", 
            "text": "Interval-related interface, used to indicate the time interval, can be initialized according to the specified nanosecond or second.", 
            "title": "Duration API"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#api-list_4", 
            "text": "Duration() {}\n  Duration(int64_t nanoseconds);\n  Duration(int nanoseconds);\n  Duration(double seconds);\n  Duration(uint32_t seconds, uint32_t nanoseconds);\n  Duration(const Rate  rate);\n  Duration(const Duration  other);\n  double ToSecond() const;\n  int64_t ToNanosecond() const;\n  bool IsZero() const;\n  void Sleep() const;\n  ```\n\n## Rate API\nThe frequency interface is generally used to initialize the time of the sleep frequency after the object is initialized according to the specified frequency.\n\n### API List\n\n```C \n  Rate(double frequency);\n  Rate(uint64_t nanoseconds);\n  Rate(const Duration );\n  void Sleep();\n  void Reset();\n  Duration CycleTime() const;\n  Duration ExpectedCycleTime() const { return expected_cycle_time_; }", 
            "title": "API List"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#recordreader-api", 
            "text": "The interface for reading the record file is used to read the message and channel information in the record file.", 
            "title": "RecordReader API"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#api-list_5", 
            "text": "C \n  RecordReader();\n  bool Open(const std::string  filename, uint64_t begin_time = 0,\n            uint64_t end_time = UINT64_MAX);\n  void Close();\n  bool ReadMessage();\n  bool EndOfFile();\n  const std::string  CurrentMessageChannelName();\n  std::shared_ptr RawMessage  CurrentRawMessage();\n  uint64_t CurrentMessageTime();", 
            "title": "API List"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#recordwriter-api", 
            "text": "The interface for writing the record file, used to record the message and channel information into the record file.", 
            "title": "RecordWriter API"
        }, 
        {
            "location": "/CyberRT_API_for_Developers/#api-list_6", 
            "text": "C \n RecordWriter();\n  bool Open(const std::string  file);\n  void Close();\n  bool WriteChannel(const std::string  name, const std::string  type,\n                    const std::string  proto_desc);\n  template  typename MessageT \n  bool WriteMessage(const std::string  channel_name, const MessageT  message,\n                    const uint64_t time_nanosec,\n                    const std::string  proto_desc = \"\");\n  bool SetSizeOfFileSegmentation(uint64_t size_kilobytes);\n  bool SetIntervalOfFileSegmentation(uint64_t time_sec);", 
            "title": "API List"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/", 
            "text": "Apollo Cyber RT Developer Tools\n\n\nApollo Cyber RT framework comes with a collection of useful tools for daily development, including one visualization tool cyber_visualizer and two command line tools cyber_monitor and cyber_recorder.\n\n\nNote: apollo docker environment is required to use the tools, please follow apollo wiki to enter docker\n\n\nAll the tools from Apollo Cyber RT rely on Apollo Cyber RT library, so you must source the setup.bash file for environment setup before using any Apollo Cyber RT tools, shown as below:\n\n\nusername@computername:~$: source /your-path-to-apollo-install-dir/cyber/setup.bash\n\n\n\n\nCyber_visualizer\n\n\nInstall and run\n\n\ncyber_visualizer\n is a visualization tool for displaying the channel data in Apollo Cyber RT.\n\n\nusername@computername:~$: source /your-path-to-apollo-install-dir/cyber/setup.bash\nusername@computername:~$: cyber_visualizer\n\n\n\n\nInteracting with cyber_visualizer\n\n\n\n\n\n\nAfter launching cyber_visualizer, you will see the following interface:\n\n\n\n\n\n\n\n\nWhen data flow through channels in Apollo Cyber RT, the list of all channels are displayed under \nChannelNames\n as seen in the figure below. For example, you can use the record tool(cyber_recorder) of Apollo Cyber RT to replay data from another terminal, then \ncyber_visualizer\n will receive information of all active channels(from replay data) and display it.\n\n\n\n\n\n\n\n\nBy clicking on options in toolbar, you can enable reference grid, display point clouds, add images, or display multiple camera's data at the same time. If you have \nShow Grid\n option enabled, you can set the color of the grid by double-clicking the \nColor\n item of the \nGrid\n list below \nChannelNames\n. The default color is gray. You can also edit the value of \nCellcount\n to adjust the number of cells in the grid.\nAs for a point cloud or an image, you can select the source channel through its \nChannelName\n sub-item, and \nAction\n sub-item to play or stop the data from the corresponding channel.\nAs shown in figure below, three cameras' channel data on the buttom sections and one point cloud channel data on the top section are displayed simultaneously.\n\n\n\n\n\n\n\n\nTo adjust the virtual camera in the 3D point cloud scene, you can right click on the point cloud display section. A dialog box will pop up as shown in figure below.\n\n\n\n\nThe point cloud scene supports two types of cameras: Free and Target.(select Type from pop up dialog above)\n- \nFree type Camera\n: For this type of camera in the point cloud scene, you can change the pose of the camera by holding down either left or right mouse button and move it. To change the pitch of camera, you can scroll the mouse wheel.\n- \nTarget type Camera\n: For this type of camera in the point cloud scene, to change the camera's viewing angle, you can hold down the left mouse button and then move it. To change the distance of the camera to the observed point (the default observation point is the coordinate system origin (0, 0,0)), you can scroll the mouse wheel.\n\n\n\n\n\n\nYou can also modify the camera information directly in the dialog box to change the camera's observation status in the point cloud scene. And the \"Step\" item is the step value from the dialog box.\n\n\nPlace the mouse on the image of the camera channel, you can double-click the left button to highlight the corresponding data channel on the left menu bar. Right click on the image to bring up menu for deleting the camera channel.\n\n\nPlay and Pause buttons: when clicking the \nPlay\n button, all channels will be showed. While when clicking the \nPause\n button, all channels will stop showing on the tool.\n\n\nCyber_monitor\n\n\nInstall and run\n\n\nThe command line tool \ncyber_monitor\n provides a clear view of the list of real time channel information Apollo Cyber RT in the terminal. \n\n\nusername@computername:~$: source /your-path-to-apollo-install-dir/cyber/setup.bash\nusername@computername:~$: cyber_monitor\n\n\n\n\nUseful commands\n\n\nDisplay help information\n\n\nUse the -h option to get help for cyber_monitor\n\n\nusername@computername:~$: cyber_monitor -h\n\n\n\n\nSpecify the channel\n\n\nWith the -c option, you can have cyber_monitor to monitor only a specified channel, such as:\n\n\nusername@computername:~$: cyber_monitor -c ChannelName\n\n\n\n\nGet familiar with UI of cyber_monitor\n\n\nAfter launching the command line tool, you will notice it is similar to cyber_visualizer. It automatically collects the information of all the channels through the topology and displays them in two columns (channel name, channel data type).\n\n\nThe default display for channel information is in red. However, if there is data flowing through the a channel, the corresponding line of the channel is displayed in green. As shown in the image below:\n\n\n\n\nInteracting with cyber_monitor\n\n\nCommon commands\n\n\nESC | q key ---- Exit\nBackspace ---- Back\nh | H ---- Show help page\n\n\n\n\nCommon command for topology and channel\n\n\nPageDown | Ctrl+d --- Next\nPageUp | Ctrl+u --- Previous\nUp, down or w, s keys ---- Move the current highlight line up and down\nRight arrow or d key ---- Enter highlight line, display highlighted line data in detail\nLeft arrow or a key ------ Return to the previous layer from the current\nEnter key ----- Same as d key\n\n\n\n\nCommands only for topology\n\n\nf | F ----- Display frame rate\nt | T ----- Display channel message type\nSpace ----- Close|Open channel (only valid for channels with data arrival; yellow color after channel is closed)\n\n\n\n\nCommands only for channel\n\n\ni | I ----- Display channel Reader and Writer information\nb | B ------ Display channel message content\n\n\n\n\nView the repeated data field in a channel\n\n\nn | N ---- Repeat the next data in the domain\nm | M ---- Repeat one data on the domain\n\n\n\n\nCyber_recorder\n\n\ncyber_recorder\n is a record/playback tool provided by Apollo Cyber RT. It provides many useful functions, including recording a record file, playing back a record file, splitting a record file, checking the information of record file and etc.\n\n\nInstall and run\n\n\nLaunch cyber_recorder:\n\n\n$ source /your-path-to-apollo-install-dir/cyber/setup.bash\n$ cyber_recorder\nusage: cyber_recorder \ncommand\n [\nargs\n]\nThe cyber_recorder commands are:\n    info                               Show infomation of an exist record.\n    play                               Play an exist record.\n    record                             Record same topic.\n    split                              Split an exist record.\n    recover                            Recover an exist record.\n\n\n\n\nCommands of cyber_recorder\n\n\n\n\nTo view the information of a record file:\n\n\n\n\n cyber_recorder info -h\nusage: cyber_recorder info [options]\n    -h, --help              show help message\n\n\n\n\n\n\nTo record a record file\n\n\n\n\n$ cyber_recorder record -h\nusage: cyber_recorder record [options]\n    -o, --output \nfile\n                output record file\n    -a, --all                          all channels\n    -c, --channel \nname\n               channel name\n    -i, --segment-interval \nseconds\n   record segmented every n second(s)\n    -m, --segment-size \nMB\n            record segmented every n megabyte(s)\n    -h, --help                         show help message\n\n\n\n\n\n\n\nTo play back a record file:\n\n\n\n\n$ cyber_recorder play -h\nusage: cyber_recorder play [options]\n    -f, --file \nfile\n           input record file  \n    -c, --white-channel \nname\n      only play the specified channel  \n    -l, --loop              loop play  \n    -r, --rate \n1.0\n            multiply the play rate by FACTOR  \n    -b, --begin \n2018-07-01 00:00:00\n   play the record begin at  \n    -e, --end \n2018-07-01 00:01:00\n play the record end at  \n    -s, --start \nseconds\n       play started at n seconds  \n    -d, --delay \nseconds\n       play delayed n seconds  \n    -p, --preload \nseconds\n     play after trying to preload n second(s)  \n    -h, --help              show help message  \n\n\n\n\n\n\nTo split a record file:\n\n\n\n\n$ cyber_recorder split -h\nusage: cyber_recorder split [options]\n    -f, --file \nfile\n                  input record file\n    -o, --output \nfile\n                output record file\n    -a, --all                          all channels\n    -c, --channel \nname\n               channel name\n    -b, --begin \n2018-07-01 00:00:00\n  begin at assigned time\n    -e, --end \n2018-07-01 01:00:00\n    end at assigned time\n\n\n\n\n\n\nTo repair a record file:\n\n\n\n\n$ cyber_recorder recover -h\nusage: cyber_recorder recover [options]\n    -f, --file \nfile\n                  input record file\n    -o, --output \nfile\n                output record file\n\n\n\n\nExamples of using cyber_recorder\n\n\nCheck the details of a record file\n\n\n$ cyber_recorder info demo.record\nrecord_file:    demo.record\nversion:        1.0\nduration:       19.995227 Seconds\nbegin_time:     2018-04-17 06:25:36\nend_time:       2018-04-17 06:25:55\nsize:           28275479 Bytes (26.965598 MB)\nis_complete:    true\nmessage_number: 15379\nchannel_number: 16\nchannel_info:   /apollo/localization/pose                             2000 messages : apollo.localization.LocalizationEstimate\n                /tf                                                   4000 messages : apollo.transform.TransformStampeds\n                /apollo/control                                       2000 messages : apollo.control.ControlCommand\n                /apollo/sensor/gnss/odometry                          2000 messages : apollo.localization.Gps\n                /apollo/canbus/chassis                                2000 messages : apollo.canbus.Chassis\n                /apollo/sensor/gnss/imu                               1999 messages : apollo.drivers.gnss.Imu\n                /apollo/sensor/gnss/rtk_obs                             41 messages : apollo.drivers.gnss.EpochObservation\n                /apollo/sensor/gnss/ins_stat                            20 messages : apollo.drivers.gnss.InsStat\n                /apollo/sensor/gnss/best_pose                           20 messages : apollo.drivers.gnss.GnssBestPose\n                /apollo/perception/obstacles                           400 messages : apollo.perception.PerceptionObstacles\n                /apollo/prediction                                     400 messages : apollo.prediction.PredictionObstacles\n                /apollo/sensor/conti_radar                             270 messages : apollo.drivers.ContiRadar\n                /apollo/planning                                       200 messages : apollo.planning.ADCTrajectory\n                /apollo/monitor/static_info                              1 messages : apollo.data.StaticInfo\n                /apollo/sensor/gnss/rtk_eph                             25 messages : apollo.drivers.gnss.GnssEphemeris\n                /apollo/monitor                                          3 messages : apollo.common.monitor.MonitorMessage\n\n\n\n\n\nRecord a record file\n\n\n$ cyber_recorder record -a\n[RUNNING]  Record :     total channel num : 1  total msg num : 5\n...\n\n\n\n\nReplay a record file\n\n\n$ cyber_recorder play -f 20180720202307.record\nfile: 20180720202307.record, chunk_number: 1, begin_time: 1532089398663399667, end_time: 1532089404688079759, message_number: 75\nplease wait for loading and playing back record...\nHit Ctrl+C to stop replay, or Space to pause.\n[RUNNING]  Record Time: 1532089404.688080    Progress: 6.024680 / 6.024680\nplay finished. file: 20180720202307.record\n\n\n\n\nrosbag_to_record\n\n\nrosbag_to_record\n is a tool which can convert rosbag to recorder file provided by Apollo Cyber RT. Now the tool support following channel:\n\n\n/apollo/perception/obstacles\n/apollo/planning\n/apollo/prediction\n/apollo/canbus/chassis\n/apollo/control\n/apollo/guardian\n/apollo/localization/pose\n/apollo/perception/traffic_light\n/apollo/drive_event\n/apollo/sensor/gnss/odometry\n/apollo/monitor/static_info\n/apollo/monitor\n/apollo/canbus/chassis_detail\n/apollo/control/pad\n/apollo/navigation\n/apollo/routing_request\n/apollo/routing_response\n/tf\n/tf_static\n/apollo/sensor/conti_radar\n/apollo/sensor/delphi_esr\n/apollo/sensor/gnss/best_pose\n/apollo/sensor/gnss/imu\n/apollo/sensor/gnss/ins_stat\n/apollo/sensor/gnss/rtk_eph\n/apollo/sensor/gnss/rtk_obs\n/apollo/sensor/velodyne64/compensator/PointCloud2\n\n\n\n\nInstall and run\n\n\nLaunch rosbag_to_record:\n\n\n$ source /your-path-to-apollo-install-dir/cyber/setup.bash\n$ rosbag_to_record\nUsage:\n  rosbag_to_record input.bag output.record\n\n\n\n\nExample\n\n\nWe can convert \nApollo2.5 demo bag\n to record file.\n\n\n$ rosbag_to_record demo_2.5.bag demo.record\nrecord_file:    demo.record\nversion:        1.0\nduration:       19.995227 Seconds\nbegin_time:     2018-04-17 06:25:36\nend_time:       2018-04-17 06:25:55\nsize:           28275479 Bytes (26.965598 MB)\nis_complete:    true\nmessage_number: 15379\nchannel_number: 16\nchannel_info:   /apollo/localization/pose                             2000 messages : apollo.localization.LocalizationEstimate\n                /tf                                                   4000 messages : apollo.transform.TransformStampeds\n                /apollo/control                                       2000 messages : apollo.control.ControlCommand\n                /apollo/sensor/gnss/odometry                          2000 messages : apollo.localization.Gps\n                /apollo/canbus/chassis                                2000 messages : apollo.canbus.Chassis\n                /apollo/sensor/gnss/imu                               1999 messages : apollo.drivers.gnss.Imu\n                /apollo/sensor/gnss/rtk_obs                             41 messages : apollo.drivers.gnss.EpochObservation\n                /apollo/sensor/gnss/ins_stat                            20 messages : apollo.drivers.gnss.InsStat\n                /apollo/sensor/gnss/best_pose                           20 messages : apollo.drivers.gnss.GnssBestPose\n                /apollo/perception/obstacles                           400 messages : apollo.perception.PerceptionObstacles\n                /apollo/prediction                                     400 messages : apollo.prediction.PredictionObstacles\n                /apollo/sensor/conti_radar                             270 messages : apollo.drivers.ContiRadar\n                /apollo/planning                                       200 messages : apollo.planning.ADCTrajectory\n                /apollo/monitor/static_info                              1 messages : apollo.data.StaticInfo\n                /apollo/sensor/gnss/rtk_eph                             25 messages : apollo.drivers.gnss.GnssEphemeris\n                /apollo/monitor                                          3 messages : apollo.common.monitor.MonitorMessage\nConvertion finished! Took 0.505623051 seconds in total.", 
            "title": "Apollo Cyber RT Developer Tools"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#apollo-cyber-rt-developer-tools", 
            "text": "Apollo Cyber RT framework comes with a collection of useful tools for daily development, including one visualization tool cyber_visualizer and two command line tools cyber_monitor and cyber_recorder.  Note: apollo docker environment is required to use the tools, please follow apollo wiki to enter docker  All the tools from Apollo Cyber RT rely on Apollo Cyber RT library, so you must source the setup.bash file for environment setup before using any Apollo Cyber RT tools, shown as below:  username@computername:~$: source /your-path-to-apollo-install-dir/cyber/setup.bash", 
            "title": "Apollo Cyber RT Developer Tools"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#cyber_visualizer", 
            "text": "", 
            "title": "Cyber_visualizer"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#install-and-run", 
            "text": "cyber_visualizer  is a visualization tool for displaying the channel data in Apollo Cyber RT.  username@computername:~$: source /your-path-to-apollo-install-dir/cyber/setup.bash\nusername@computername:~$: cyber_visualizer", 
            "title": "Install and run"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#interacting-with-cyber_visualizer", 
            "text": "After launching cyber_visualizer, you will see the following interface:     When data flow through channels in Apollo Cyber RT, the list of all channels are displayed under  ChannelNames  as seen in the figure below. For example, you can use the record tool(cyber_recorder) of Apollo Cyber RT to replay data from another terminal, then  cyber_visualizer  will receive information of all active channels(from replay data) and display it.     By clicking on options in toolbar, you can enable reference grid, display point clouds, add images, or display multiple camera's data at the same time. If you have  Show Grid  option enabled, you can set the color of the grid by double-clicking the  Color  item of the  Grid  list below  ChannelNames . The default color is gray. You can also edit the value of  Cellcount  to adjust the number of cells in the grid.\nAs for a point cloud or an image, you can select the source channel through its  ChannelName  sub-item, and  Action  sub-item to play or stop the data from the corresponding channel.\nAs shown in figure below, three cameras' channel data on the buttom sections and one point cloud channel data on the top section are displayed simultaneously.     To adjust the virtual camera in the 3D point cloud scene, you can right click on the point cloud display section. A dialog box will pop up as shown in figure below.   The point cloud scene supports two types of cameras: Free and Target.(select Type from pop up dialog above)\n-  Free type Camera : For this type of camera in the point cloud scene, you can change the pose of the camera by holding down either left or right mouse button and move it. To change the pitch of camera, you can scroll the mouse wheel.\n-  Target type Camera : For this type of camera in the point cloud scene, to change the camera's viewing angle, you can hold down the left mouse button and then move it. To change the distance of the camera to the observed point (the default observation point is the coordinate system origin (0, 0,0)), you can scroll the mouse wheel.    You can also modify the camera information directly in the dialog box to change the camera's observation status in the point cloud scene. And the \"Step\" item is the step value from the dialog box.  Place the mouse on the image of the camera channel, you can double-click the left button to highlight the corresponding data channel on the left menu bar. Right click on the image to bring up menu for deleting the camera channel.  Play and Pause buttons: when clicking the  Play  button, all channels will be showed. While when clicking the  Pause  button, all channels will stop showing on the tool.", 
            "title": "Interacting with cyber_visualizer"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#cyber_monitor", 
            "text": "", 
            "title": "Cyber_monitor"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#install-and-run_1", 
            "text": "The command line tool  cyber_monitor  provides a clear view of the list of real time channel information Apollo Cyber RT in the terminal.   username@computername:~$: source /your-path-to-apollo-install-dir/cyber/setup.bash\nusername@computername:~$: cyber_monitor", 
            "title": "Install and run"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#useful-commands", 
            "text": "", 
            "title": "Useful commands"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#display-help-information", 
            "text": "Use the -h option to get help for cyber_monitor  username@computername:~$: cyber_monitor -h", 
            "title": "Display help information"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#specify-the-channel", 
            "text": "With the -c option, you can have cyber_monitor to monitor only a specified channel, such as:  username@computername:~$: cyber_monitor -c ChannelName", 
            "title": "Specify the channel"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#get-familiar-with-ui-of-cyber_monitor", 
            "text": "After launching the command line tool, you will notice it is similar to cyber_visualizer. It automatically collects the information of all the channels through the topology and displays them in two columns (channel name, channel data type).  The default display for channel information is in red. However, if there is data flowing through the a channel, the corresponding line of the channel is displayed in green. As shown in the image below:", 
            "title": "Get familiar with UI of cyber_monitor"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#interacting-with-cyber_monitor", 
            "text": "", 
            "title": "Interacting with cyber_monitor"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#common-commands", 
            "text": "ESC | q key ---- Exit\nBackspace ---- Back\nh | H ---- Show help page", 
            "title": "Common commands"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#common-command-for-topology-and-channel", 
            "text": "PageDown | Ctrl+d --- Next\nPageUp | Ctrl+u --- Previous\nUp, down or w, s keys ---- Move the current highlight line up and down\nRight arrow or d key ---- Enter highlight line, display highlighted line data in detail\nLeft arrow or a key ------ Return to the previous layer from the current\nEnter key ----- Same as d key", 
            "title": "Common command for topology and channel"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#commands-only-for-topology", 
            "text": "f | F ----- Display frame rate\nt | T ----- Display channel message type\nSpace ----- Close|Open channel (only valid for channels with data arrival; yellow color after channel is closed)", 
            "title": "Commands only for topology"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#commands-only-for-channel", 
            "text": "i | I ----- Display channel Reader and Writer information\nb | B ------ Display channel message content", 
            "title": "Commands only for channel"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#view-the-repeated-data-field-in-a-channel", 
            "text": "n | N ---- Repeat the next data in the domain\nm | M ---- Repeat one data on the domain", 
            "title": "View the repeated data field in a channel"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#cyber_recorder", 
            "text": "cyber_recorder  is a record/playback tool provided by Apollo Cyber RT. It provides many useful functions, including recording a record file, playing back a record file, splitting a record file, checking the information of record file and etc.", 
            "title": "Cyber_recorder"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#install-and-run_2", 
            "text": "Launch cyber_recorder:  $ source /your-path-to-apollo-install-dir/cyber/setup.bash\n$ cyber_recorder\nusage: cyber_recorder  command  [ args ]\nThe cyber_recorder commands are:\n    info                               Show infomation of an exist record.\n    play                               Play an exist record.\n    record                             Record same topic.\n    split                              Split an exist record.\n    recover                            Recover an exist record.", 
            "title": "Install and run"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#commands-of-cyber_recorder", 
            "text": "To view the information of a record file:    cyber_recorder info -h\nusage: cyber_recorder info [options]\n    -h, --help              show help message   To record a record file   $ cyber_recorder record -h\nusage: cyber_recorder record [options]\n    -o, --output  file                 output record file\n    -a, --all                          all channels\n    -c, --channel  name                channel name\n    -i, --segment-interval  seconds    record segmented every n second(s)\n    -m, --segment-size  MB             record segmented every n megabyte(s)\n    -h, --help                         show help message   To play back a record file:   $ cyber_recorder play -h\nusage: cyber_recorder play [options]\n    -f, --file  file            input record file  \n    -c, --white-channel  name       only play the specified channel  \n    -l, --loop              loop play  \n    -r, --rate  1.0             multiply the play rate by FACTOR  \n    -b, --begin  2018-07-01 00:00:00    play the record begin at  \n    -e, --end  2018-07-01 00:01:00  play the record end at  \n    -s, --start  seconds        play started at n seconds  \n    -d, --delay  seconds        play delayed n seconds  \n    -p, --preload  seconds      play after trying to preload n second(s)  \n    -h, --help              show help message     To split a record file:   $ cyber_recorder split -h\nusage: cyber_recorder split [options]\n    -f, --file  file                   input record file\n    -o, --output  file                 output record file\n    -a, --all                          all channels\n    -c, --channel  name                channel name\n    -b, --begin  2018-07-01 00:00:00   begin at assigned time\n    -e, --end  2018-07-01 01:00:00     end at assigned time   To repair a record file:   $ cyber_recorder recover -h\nusage: cyber_recorder recover [options]\n    -f, --file  file                   input record file\n    -o, --output  file                 output record file", 
            "title": "Commands of cyber_recorder"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#examples-of-using-cyber_recorder", 
            "text": "", 
            "title": "Examples of using cyber_recorder"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#check-the-details-of-a-record-file", 
            "text": "$ cyber_recorder info demo.record\nrecord_file:    demo.record\nversion:        1.0\nduration:       19.995227 Seconds\nbegin_time:     2018-04-17 06:25:36\nend_time:       2018-04-17 06:25:55\nsize:           28275479 Bytes (26.965598 MB)\nis_complete:    true\nmessage_number: 15379\nchannel_number: 16\nchannel_info:   /apollo/localization/pose                             2000 messages : apollo.localization.LocalizationEstimate\n                /tf                                                   4000 messages : apollo.transform.TransformStampeds\n                /apollo/control                                       2000 messages : apollo.control.ControlCommand\n                /apollo/sensor/gnss/odometry                          2000 messages : apollo.localization.Gps\n                /apollo/canbus/chassis                                2000 messages : apollo.canbus.Chassis\n                /apollo/sensor/gnss/imu                               1999 messages : apollo.drivers.gnss.Imu\n                /apollo/sensor/gnss/rtk_obs                             41 messages : apollo.drivers.gnss.EpochObservation\n                /apollo/sensor/gnss/ins_stat                            20 messages : apollo.drivers.gnss.InsStat\n                /apollo/sensor/gnss/best_pose                           20 messages : apollo.drivers.gnss.GnssBestPose\n                /apollo/perception/obstacles                           400 messages : apollo.perception.PerceptionObstacles\n                /apollo/prediction                                     400 messages : apollo.prediction.PredictionObstacles\n                /apollo/sensor/conti_radar                             270 messages : apollo.drivers.ContiRadar\n                /apollo/planning                                       200 messages : apollo.planning.ADCTrajectory\n                /apollo/monitor/static_info                              1 messages : apollo.data.StaticInfo\n                /apollo/sensor/gnss/rtk_eph                             25 messages : apollo.drivers.gnss.GnssEphemeris\n                /apollo/monitor                                          3 messages : apollo.common.monitor.MonitorMessage", 
            "title": "Check the details of a record file"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#record-a-record-file", 
            "text": "$ cyber_recorder record -a\n[RUNNING]  Record :     total channel num : 1  total msg num : 5\n...", 
            "title": "Record a record file"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#replay-a-record-file", 
            "text": "$ cyber_recorder play -f 20180720202307.record\nfile: 20180720202307.record, chunk_number: 1, begin_time: 1532089398663399667, end_time: 1532089404688079759, message_number: 75\nplease wait for loading and playing back record...\nHit Ctrl+C to stop replay, or Space to pause.\n[RUNNING]  Record Time: 1532089404.688080    Progress: 6.024680 / 6.024680\nplay finished. file: 20180720202307.record", 
            "title": "Replay a record file"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#rosbag_to95record", 
            "text": "rosbag_to_record  is a tool which can convert rosbag to recorder file provided by Apollo Cyber RT. Now the tool support following channel:  /apollo/perception/obstacles\n/apollo/planning\n/apollo/prediction\n/apollo/canbus/chassis\n/apollo/control\n/apollo/guardian\n/apollo/localization/pose\n/apollo/perception/traffic_light\n/apollo/drive_event\n/apollo/sensor/gnss/odometry\n/apollo/monitor/static_info\n/apollo/monitor\n/apollo/canbus/chassis_detail\n/apollo/control/pad\n/apollo/navigation\n/apollo/routing_request\n/apollo/routing_response\n/tf\n/tf_static\n/apollo/sensor/conti_radar\n/apollo/sensor/delphi_esr\n/apollo/sensor/gnss/best_pose\n/apollo/sensor/gnss/imu\n/apollo/sensor/gnss/ins_stat\n/apollo/sensor/gnss/rtk_eph\n/apollo/sensor/gnss/rtk_obs\n/apollo/sensor/velodyne64/compensator/PointCloud2", 
            "title": "rosbag_to_record"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#install-and-run_3", 
            "text": "Launch rosbag_to_record:  $ source /your-path-to-apollo-install-dir/cyber/setup.bash\n$ rosbag_to_record\nUsage:\n  rosbag_to_record input.bag output.record", 
            "title": "Install and run"
        }, 
        {
            "location": "/CyberRT_Developer_Tools/#example", 
            "text": "We can convert  Apollo2.5 demo bag  to record file.  $ rosbag_to_record demo_2.5.bag demo.record\nrecord_file:    demo.record\nversion:        1.0\nduration:       19.995227 Seconds\nbegin_time:     2018-04-17 06:25:36\nend_time:       2018-04-17 06:25:55\nsize:           28275479 Bytes (26.965598 MB)\nis_complete:    true\nmessage_number: 15379\nchannel_number: 16\nchannel_info:   /apollo/localization/pose                             2000 messages : apollo.localization.LocalizationEstimate\n                /tf                                                   4000 messages : apollo.transform.TransformStampeds\n                /apollo/control                                       2000 messages : apollo.control.ControlCommand\n                /apollo/sensor/gnss/odometry                          2000 messages : apollo.localization.Gps\n                /apollo/canbus/chassis                                2000 messages : apollo.canbus.Chassis\n                /apollo/sensor/gnss/imu                               1999 messages : apollo.drivers.gnss.Imu\n                /apollo/sensor/gnss/rtk_obs                             41 messages : apollo.drivers.gnss.EpochObservation\n                /apollo/sensor/gnss/ins_stat                            20 messages : apollo.drivers.gnss.InsStat\n                /apollo/sensor/gnss/best_pose                           20 messages : apollo.drivers.gnss.GnssBestPose\n                /apollo/perception/obstacles                           400 messages : apollo.perception.PerceptionObstacles\n                /apollo/prediction                                     400 messages : apollo.prediction.PredictionObstacles\n                /apollo/sensor/conti_radar                             270 messages : apollo.drivers.ContiRadar\n                /apollo/planning                                       200 messages : apollo.planning.ADCTrajectory\n                /apollo/monitor/static_info                              1 messages : apollo.data.StaticInfo\n                /apollo/sensor/gnss/rtk_eph                             25 messages : apollo.drivers.gnss.GnssEphemeris\n                /apollo/monitor                                          3 messages : apollo.common.monitor.MonitorMessage\nConvertion finished! Took 0.505623051 seconds in total.", 
            "title": "Example"
        }, 
        {
            "location": "/CyberRT_FAQs/", 
            "text": "Apollo Cyber RT FAQs\n\n\nWhat is Apollo Cyber RT?\n\n\nApollo's Cyber RT is an open source runtime framework designed specifically for autonomous driving scenarios. Based on a centralized computing model, it is highly optimized for performance, latency, and data throughput\n\n\n\n\nWhy did we decide to work on a new runtime framework?\n\n\n\n\n\n\nDuring years of development of autonomous driving technologies, we have learned a lot from our previous experience with Apollo. In autonomous driving scenarious, we need an effective centralized computing model, with demands for high performance,  including high concurrency, low latency and high throughput\u3002\n\n\n\n\n\n\nThe industry is evolving, so does Apollo. Going forward, Apollo has already moved from development to productization, with volume deployments in the real world, we see the demands for the highest robustness and high performance. That\u2019s why we spent years of building Apollo Cyber RT, which addresses that requirements of autonomous driving solutions. \n\n\n\n\n\n\n\n\nWhat are the advantages of the new runtime framework?\n\n\n\n\nAccelerate development\n\n\nWell defined task interface with data fusion\n\n\nArray of development tools\n\n\nLarge set of sensor drivers\n\n\nSimplify deployment\n\n\nEfficient and adaptive message communication\n\n\nConfigurable user level scheduler with resource awareness\n\n\nPortable with fewer dependencies\n\n\nEmpower your own autonomous vehicles\n\n\nThe default open source runtime framework\n\n\nBuilding blocks specifically designed for autonomous driving\n\n\nPlug and play your own AD system\n\n\n\n\n\n\nCan we still use the data that we have collected?\n\n\n\n\nIf the data you have collected is compatible with the previous versions of Apollo, you could use our recommended conversion tools to make the data compliant with our new runtime framework\n\n\nIf you created a customized data format, then the previously generated data will not be supported by the new runtime framework\n\n\n\n\n\n\nWill you continue to support ROS?\n\n\nWe will continue to support previous Apollo releases (3.0 and before) based on ROS. We do appreciate you continue growing with us and highly encourage you to move to Apollo 3.5. While we know that some of our developers would prefer to work on ROS, we do hope you will understand why Apollo as a team cannot continue to support ROS in our future releases as we strive to work towards developing a more holistic platform that meets automotive standards. \n\n\n\n\nWill Apollo Cyber RT affect regular code development?\n\n\nIf you have not modified anything at runtime framework layer and have only worked on Apollo's module code base, you will not be affected by the introduction of our new runtime framework as most of time you would only need to re-interface the access of the input and output data. Additional documents are under \ncyber\n with more details.\n\n\n\n\nRecommended setup for Apollo Cyber RT\n\n\n\n\nCurrently the runtime framework only supports running on Trusty (Ubuntu 14.04)\n\n\nThe runtime framework also uses apollo's docker environment\n\n\nIt is recommended to run source setup.bash when opening a new terminal\n\n\nFork and clone the Apollo repo with the new framework code which can be found at \napollo/cyber\n\n\n\n\n\n\nMore FAQs to follow...", 
            "title": "Apollo Cyber RT FAQs"
        }, 
        {
            "location": "/CyberRT_FAQs/#apollo-cyber-rt-faqs", 
            "text": "", 
            "title": "Apollo Cyber RT FAQs"
        }, 
        {
            "location": "/CyberRT_FAQs/#what-is-apollo-cyber-rt", 
            "text": "Apollo's Cyber RT is an open source runtime framework designed specifically for autonomous driving scenarios. Based on a centralized computing model, it is highly optimized for performance, latency, and data throughput", 
            "title": "What is Apollo Cyber RT?"
        }, 
        {
            "location": "/CyberRT_FAQs/#why-did-we-decide-to-work-on-a-new-runtime-framework", 
            "text": "During years of development of autonomous driving technologies, we have learned a lot from our previous experience with Apollo. In autonomous driving scenarious, we need an effective centralized computing model, with demands for high performance,  including high concurrency, low latency and high throughput\u3002    The industry is evolving, so does Apollo. Going forward, Apollo has already moved from development to productization, with volume deployments in the real world, we see the demands for the highest robustness and high performance. That\u2019s why we spent years of building Apollo Cyber RT, which addresses that requirements of autonomous driving solutions.", 
            "title": "Why did we decide to work on a new runtime framework?"
        }, 
        {
            "location": "/CyberRT_FAQs/#what-are-the-advantages-of-the-new-runtime-framework", 
            "text": "Accelerate development  Well defined task interface with data fusion  Array of development tools  Large set of sensor drivers  Simplify deployment  Efficient and adaptive message communication  Configurable user level scheduler with resource awareness  Portable with fewer dependencies  Empower your own autonomous vehicles  The default open source runtime framework  Building blocks specifically designed for autonomous driving  Plug and play your own AD system", 
            "title": "What are the advantages of the new runtime framework?"
        }, 
        {
            "location": "/CyberRT_FAQs/#can-we-still-use-the-data-that-we-have-collected", 
            "text": "If the data you have collected is compatible with the previous versions of Apollo, you could use our recommended conversion tools to make the data compliant with our new runtime framework  If you created a customized data format, then the previously generated data will not be supported by the new runtime framework", 
            "title": "Can we still use the data that we have collected?"
        }, 
        {
            "location": "/CyberRT_FAQs/#will-you-continue-to-support-ros", 
            "text": "We will continue to support previous Apollo releases (3.0 and before) based on ROS. We do appreciate you continue growing with us and highly encourage you to move to Apollo 3.5. While we know that some of our developers would prefer to work on ROS, we do hope you will understand why Apollo as a team cannot continue to support ROS in our future releases as we strive to work towards developing a more holistic platform that meets automotive standards.", 
            "title": "Will you continue to support ROS?"
        }, 
        {
            "location": "/CyberRT_FAQs/#will-apollo-cyber-rt-affect-regular-code-development", 
            "text": "If you have not modified anything at runtime framework layer and have only worked on Apollo's module code base, you will not be affected by the introduction of our new runtime framework as most of time you would only need to re-interface the access of the input and output data. Additional documents are under  cyber  with more details.", 
            "title": "Will Apollo Cyber RT affect regular code development?"
        }, 
        {
            "location": "/CyberRT_FAQs/#recommended-setup-for-apollo-cyber-rt", 
            "text": "Currently the runtime framework only supports running on Trusty (Ubuntu 14.04)  The runtime framework also uses apollo's docker environment  It is recommended to run source setup.bash when opening a new terminal  Fork and clone the Apollo repo with the new framework code which can be found at  apollo/cyber    More FAQs to follow...", 
            "title": "Recommended setup for Apollo Cyber RT"
        }, 
        {
            "location": "/CyberRT_Migration_Guide/", 
            "text": "Migration guide from Apollo ROS\n\n\nThis article describes the essential changes for projects to migrate from Apollo ROS(3.0 and before) to Apollo Cyber-RT(3.5). We will be using the very first ROS project talker/listener as example to demostrate step by step migration instruction.\n\n\nBuild system\n\n\nROS use \nCMake\n as its build system but Cyber-RT use \nbazel\n. In a ROS project, CmakeLists.txt and package.xml are required for defining build configs like build target, dependency, message files and so on. As for a Cyber-RT component, a single bazel BUILD file covers. Some key build config mappings are listed below.\n\n\nCmake\n\n\nproject(pb_msgs_example)\nadd_proto_files(\n  DIRECTORY proto\n  FILES chatter.proto\n)\n## Declare a C++ executable\nadd_executable(pb_talker src/talker.cpp)\ntarget_link_libraries(pb_talker ${catkin_LIBRARIES}pb_msgs_example_proto)\nadd_executable(pb_listener src/listener.cpp)\ntarget_link_libraries(pb_listener ${catkin_LIBRARIES}  pb_msgs_example_proto)\n\n\n\n\nBazel\n\n\ncc_binary(\n  name = \ntalker\n,\n  srcs = [\ntalker.cc\n],\n  deps = [\n    \n//cyber\n,\n    \n//cyber/examples/proto:examples_cc_proto\n,\n    ],\n  )\ncc_binary(\n  name = \nlistener\n,\n  srcs = [\nlistener.cc\n],\n  deps = [\n    \n//cyber\n,\n    \n//cyber/examples/proto:examples_cc_proto\n,\n    ],\n  )\n\n\n\n\nWe can find the mapping easily from the 2 file snippets. For example, \npb_talker\n and \nsrc/talker.cpp\n in cmake \nadd_executable\n setting map to \nname = \"talker\"\n and \nsrcs = [\"talker.cc\"]\n in BUILD file \ncc_binary\n.\n\n\nProto\n\n\nApollo ROS has customized to support proto message formate that a separate section \nadd_proto_files\n and projectName_proto(\npb_msgs_example_proto\n) in \ntarget_link_libraries\n are required to send message in proto formate. For config proto message in Cyber-RT, it's as simple as adding the target proto file path concantenated with name of \ncc_proto_library\n in \ndeps\n setting. The \ncc_proto_library\n is set up in BUILD file under proto folder. \n\n\ncc_proto_library(\n  name = \nexamples_cc_proto\n,\n  deps = [\n    \n:examples_proto\n,\n  ],\n)\nproto_library(\n  name = \nexamples_proto\n,\n  srcs = [\n    \nexamples.proto\n,\n  ],\n)\n\n\n\n\nThe package definition has also changed in Cyber-RT. In Apollo ROS a fixed package \npackage pb_msgs;\n is used for proto files, but in Cyber-RT, the proto file path \npackage apollo.cyber.examples.proto;\n is used instead. \n\n\nFolder structure\n\n\nAs shown below, Cyber-RT remove the src folder and pull all source code in the same folder as BUILD file. BUILD file plays the same role as CMakeLists.txt plus package.xml. Both Cyber-RT and Apollo ROS talker/listener example have a proto folder for message proto files but Cyber-RT requires a separate BUILD file for proto folder to set up the proto library.\n\n\nApollo ROS\n\n\n\n\nCMakeLists.txt\n\n\npackage.xml\n\n\nproto\n\n\nchatter.proto  \n\n\nsrc\n\n\nlistener.cpp\n\n\ntalker.cpp\n\n\n\n\nCyber-RT\n\n\n\n\nBUILD\n\n\nlistener.ccc\n\n\ntalker.cc\n\n\nproto\n\n\nBUILD\n\n\nexamples.proto (with chatter message)   \n\n\n\n\nUpdate source code\n\n\nListener\n\n\nCyber-RT\n\n\n#include \ncyber/cyber.h\n\n#include \ncyber/examples/proto/examples.pb.h\n\n\nvoid MessageCallback(\n    const std::shared_ptr\napollo::cyber::examples::proto::Chatter\n msg) {\n  AINFO \n \nReceived message seq-\n \n \n msg-\nseq();\n  AINFO \n \nmsgcontent-\n \n msg-\ncontent();\n}\n\nint main(int argc, char* argv[]) {\n  // init cyber framework\n  apollo::cyber::Init(argv[0]);\n  // create listener node\n  auto listener_node = apollo::cyber::CreateNode(\nlistener\n);\n  // create listener\n  auto listener =\n      listener_node-\nCreateReader\napollo::cyber::examples::proto::Chatter\n(\n          \nchannel/chatter\n, MessageCallback);\n  apollo::cyber::WaitForShutdown();\n  return 0;\n}\n\n\n\n\nROS\n\n\n#include \nros/ros.h\n\n#include \nchatter.pb.h\n\n\nvoid MessageCallback(const boost::shared_ptr\npb_msgs::Chatter\n msg) {\n  ROS_INFO_STREAM(\nTime: \n \n msg-\nstamp().sec() \n \n.\n \n msg-\nstamp().nsec());\n  ROS_INFO(\nI heard pb Chatter message: [%s]\n, msg-\ncontent().c_str());\n}\n\nint main(int argc, char** argv) {\n  ros::init(argc, argv, \nlistener\n);\n  ros::NodeHandle n;\n  ros::Subscriber pb_sub = n.subscribe(\nchatter\n, 1000, MessageCallback);\n  ros::spin();\n  return 0;\n}\n\n\n\n\nYou can see easily from the two listener code above that Cyber-RT provides very similar API to for developers to migrate from ROS.  \n\n\n\n\nros::init(argc, argv, \"listener\");\n --\n \napollo::cyber::Init(argv[0]);\n\n\nros::NodeHandle n;\n --\n \nauto listener_node = apollo::cyber::CreateNode(\"listener\");\n\n\nros::Subscriber pb_sub = n.subscribe(\"chatter\", 1000, MessageCallback);\n --\n \nauto listener =\n      listener_node-\nCreateReader(\"channel/chatter\", MessageCallback);\n\n\nros::spin();\n --\n \napollo::cyber::WaitForShutdown();\n\n\n\n\nNote: for Cyber-RT, a listener node has to use \nnode-\nCreateReader\nmessageType\n(channelName, callback)\n to read data from channel.\n\n\nTalker\n\n\nCyber-RT\n\n\n#include \ncyber/cyber.h\n\n#include \ncyber/examples/proto/examples.pb.h\n\n\nusing apollo::cyber::examples::proto::Chatter;\n\nint main(int argc, char *argv[]) {\n  // init cyber framework\n  apollo::cyber::Init(argv[0]);\n  // create talker node\n  auto talker_node = apollo::cyber::CreateNode(\ntalker\n);\n  // create talker\n  auto talker = talker_node-\nCreateWriter\nChatter\n(\nchannel/chatter\n);\n  Rate rate(1.0);\n  while (apollo::cyber::OK()) {\n    static uint64_t seq = 0;\n    auto msg = std::make_shared\nChatter\n();\n    msg-\nset_timestamp(Time::Now().ToNanosecond());\n    msg-\nset_lidar_timestamp(Time::Now().ToNanosecond());\n    msg-\nset_seq(seq++);\n    msg-\nset_content(\nHello, apollo!\n);\n    talker-\nWrite(msg);\n    AINFO \n \ntalker sent a message!\n;\n    rate.Sleep();\n  }\n  return 0;\n}\n\n\n\n\nROS\n\n\n#include \nros/ros.h\n\n#include \nchatter.pb.h\n\n\n#include \nsstream\n\n\nint main(int argc, char** argv) {\n  ros::init(argc, argv, \ntalker\n);\n  ros::NodeHandle n;\n  ros::Publisher chatter_pub = n.advertise\npb_msgs::Chatter\n(\nchatter\n, 1000);\n  ros::Rate loop_rate(10);\n  int count = 0;\n  while (ros::ok()) {\n    pb_msgs::Chatter msg;\n    ros::Time now = ros::Time::now();\n    msg.mutable_stamp()-\nset_sec(now.sec);\n    msg.mutable_stamp()-\nset_nsec(now.nsec);\n    std::stringstream ss; \n    ss \n \nHello world \n \n count;\n    msg.set_content(ss.str());\n    chatter_pub.publish(msg);   \n    ros::spinOnce();\n    loop_rate.sleep();\n  }\n  return 0;\n}\n\n\n\n\nMost of the mappings are illustrated in listener code above, the rest are listed here. \n\n\n\n\n\n\nros::Publisher chatter_pub = n.advertise\npb_msgs::Chatter\n(\"chatter\", 1000);\n --\n \nauto talker = talker_node-\nCreateWriter\nChatter\n(\"channel/chatter\");\n\n\n\n\n\n\nchatter_pub.publish(msg);\n --\n \ntalker-\nWrite(msg);\n\n\n\n\n\n\nTools mapping\n\n\n\n\n\n\n\n\nROS\n\n\nCyber-RT\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nrosbag\n\n\ncyber_recorder\n\n\ndata file\n\n\n\n\n\n\nscripts/diagnostics.sh\n\n\ncyber_monitor\n\n\nchannel debug\n\n\n\n\n\n\noffline_lidar_visualizer_tool\n\n\ncyber_visualizer\n\n\npoint cloud visualizer\n\n\n\n\n\n\n\n\nROS bag data migration\n\n\nThe data file changed from ROS bag to Cyber record in Cyber-RT. Cyber-RT has a data migration tool \nrosbag_to_record\n for users to easily migrate data files before Apollo 3.0 (ROS) to Cyber-RT like the sample usage below. \n\n\nrosbag_to_record demo_3.0.bag demo_3.5.record", 
            "title": "Migration guide from Apollo ROS"
        }, 
        {
            "location": "/CyberRT_Migration_Guide/#migration-guide-from-apollo-ros", 
            "text": "This article describes the essential changes for projects to migrate from Apollo ROS(3.0 and before) to Apollo Cyber-RT(3.5). We will be using the very first ROS project talker/listener as example to demostrate step by step migration instruction.", 
            "title": "Migration guide from Apollo ROS"
        }, 
        {
            "location": "/CyberRT_Migration_Guide/#build-system", 
            "text": "ROS use  CMake  as its build system but Cyber-RT use  bazel . In a ROS project, CmakeLists.txt and package.xml are required for defining build configs like build target, dependency, message files and so on. As for a Cyber-RT component, a single bazel BUILD file covers. Some key build config mappings are listed below.  Cmake  project(pb_msgs_example)\nadd_proto_files(\n  DIRECTORY proto\n  FILES chatter.proto\n)\n## Declare a C++ executable\nadd_executable(pb_talker src/talker.cpp)\ntarget_link_libraries(pb_talker ${catkin_LIBRARIES}pb_msgs_example_proto)\nadd_executable(pb_listener src/listener.cpp)\ntarget_link_libraries(pb_listener ${catkin_LIBRARIES}  pb_msgs_example_proto)  Bazel  cc_binary(\n  name =  talker ,\n  srcs = [ talker.cc ],\n  deps = [\n     //cyber ,\n     //cyber/examples/proto:examples_cc_proto ,\n    ],\n  )\ncc_binary(\n  name =  listener ,\n  srcs = [ listener.cc ],\n  deps = [\n     //cyber ,\n     //cyber/examples/proto:examples_cc_proto ,\n    ],\n  )  We can find the mapping easily from the 2 file snippets. For example,  pb_talker  and  src/talker.cpp  in cmake  add_executable  setting map to  name = \"talker\"  and  srcs = [\"talker.cc\"]  in BUILD file  cc_binary .", 
            "title": "Build system"
        }, 
        {
            "location": "/CyberRT_Migration_Guide/#proto", 
            "text": "Apollo ROS has customized to support proto message formate that a separate section  add_proto_files  and projectName_proto( pb_msgs_example_proto ) in  target_link_libraries  are required to send message in proto formate. For config proto message in Cyber-RT, it's as simple as adding the target proto file path concantenated with name of  cc_proto_library  in  deps  setting. The  cc_proto_library  is set up in BUILD file under proto folder.   cc_proto_library(\n  name =  examples_cc_proto ,\n  deps = [\n     :examples_proto ,\n  ],\n)\nproto_library(\n  name =  examples_proto ,\n  srcs = [\n     examples.proto ,\n  ],\n)  The package definition has also changed in Cyber-RT. In Apollo ROS a fixed package  package pb_msgs;  is used for proto files, but in Cyber-RT, the proto file path  package apollo.cyber.examples.proto;  is used instead.", 
            "title": "Proto"
        }, 
        {
            "location": "/CyberRT_Migration_Guide/#folder-structure", 
            "text": "As shown below, Cyber-RT remove the src folder and pull all source code in the same folder as BUILD file. BUILD file plays the same role as CMakeLists.txt plus package.xml. Both Cyber-RT and Apollo ROS talker/listener example have a proto folder for message proto files but Cyber-RT requires a separate BUILD file for proto folder to set up the proto library.", 
            "title": "Folder structure"
        }, 
        {
            "location": "/CyberRT_Migration_Guide/#apollo-ros", 
            "text": "CMakeLists.txt  package.xml  proto  chatter.proto    src  listener.cpp  talker.cpp", 
            "title": "Apollo ROS"
        }, 
        {
            "location": "/CyberRT_Migration_Guide/#cyber-rt", 
            "text": "BUILD  listener.ccc  talker.cc  proto  BUILD  examples.proto (with chatter message)", 
            "title": "Cyber-RT"
        }, 
        {
            "location": "/CyberRT_Migration_Guide/#update-source-code", 
            "text": "", 
            "title": "Update source code"
        }, 
        {
            "location": "/CyberRT_Migration_Guide/#listener", 
            "text": "Cyber-RT  #include  cyber/cyber.h \n#include  cyber/examples/proto/examples.pb.h \n\nvoid MessageCallback(\n    const std::shared_ptr apollo::cyber::examples::proto::Chatter  msg) {\n  AINFO    Received message seq-      msg- seq();\n  AINFO    msgcontent-    msg- content();\n}\n\nint main(int argc, char* argv[]) {\n  // init cyber framework\n  apollo::cyber::Init(argv[0]);\n  // create listener node\n  auto listener_node = apollo::cyber::CreateNode( listener );\n  // create listener\n  auto listener =\n      listener_node- CreateReader apollo::cyber::examples::proto::Chatter (\n           channel/chatter , MessageCallback);\n  apollo::cyber::WaitForShutdown();\n  return 0;\n}  ROS  #include  ros/ros.h \n#include  chatter.pb.h \n\nvoid MessageCallback(const boost::shared_ptr pb_msgs::Chatter  msg) {\n  ROS_INFO_STREAM( Time:     msg- stamp().sec()    .    msg- stamp().nsec());\n  ROS_INFO( I heard pb Chatter message: [%s] , msg- content().c_str());\n}\n\nint main(int argc, char** argv) {\n  ros::init(argc, argv,  listener );\n  ros::NodeHandle n;\n  ros::Subscriber pb_sub = n.subscribe( chatter , 1000, MessageCallback);\n  ros::spin();\n  return 0;\n}  You can see easily from the two listener code above that Cyber-RT provides very similar API to for developers to migrate from ROS.     ros::init(argc, argv, \"listener\");  --   apollo::cyber::Init(argv[0]);  ros::NodeHandle n;  --   auto listener_node = apollo::cyber::CreateNode(\"listener\");  ros::Subscriber pb_sub = n.subscribe(\"chatter\", 1000, MessageCallback);  --   auto listener =\n      listener_node- CreateReader(\"channel/chatter\", MessageCallback);  ros::spin();  --   apollo::cyber::WaitForShutdown();   Note: for Cyber-RT, a listener node has to use  node- CreateReader messageType (channelName, callback)  to read data from channel.", 
            "title": "Listener"
        }, 
        {
            "location": "/CyberRT_Migration_Guide/#talker", 
            "text": "Cyber-RT  #include  cyber/cyber.h \n#include  cyber/examples/proto/examples.pb.h \n\nusing apollo::cyber::examples::proto::Chatter;\n\nint main(int argc, char *argv[]) {\n  // init cyber framework\n  apollo::cyber::Init(argv[0]);\n  // create talker node\n  auto talker_node = apollo::cyber::CreateNode( talker );\n  // create talker\n  auto talker = talker_node- CreateWriter Chatter ( channel/chatter );\n  Rate rate(1.0);\n  while (apollo::cyber::OK()) {\n    static uint64_t seq = 0;\n    auto msg = std::make_shared Chatter ();\n    msg- set_timestamp(Time::Now().ToNanosecond());\n    msg- set_lidar_timestamp(Time::Now().ToNanosecond());\n    msg- set_seq(seq++);\n    msg- set_content( Hello, apollo! );\n    talker- Write(msg);\n    AINFO    talker sent a message! ;\n    rate.Sleep();\n  }\n  return 0;\n}  ROS  #include  ros/ros.h \n#include  chatter.pb.h \n\n#include  sstream \n\nint main(int argc, char** argv) {\n  ros::init(argc, argv,  talker );\n  ros::NodeHandle n;\n  ros::Publisher chatter_pub = n.advertise pb_msgs::Chatter ( chatter , 1000);\n  ros::Rate loop_rate(10);\n  int count = 0;\n  while (ros::ok()) {\n    pb_msgs::Chatter msg;\n    ros::Time now = ros::Time::now();\n    msg.mutable_stamp()- set_sec(now.sec);\n    msg.mutable_stamp()- set_nsec(now.nsec);\n    std::stringstream ss; \n    ss    Hello world     count;\n    msg.set_content(ss.str());\n    chatter_pub.publish(msg);   \n    ros::spinOnce();\n    loop_rate.sleep();\n  }\n  return 0;\n}  Most of the mappings are illustrated in listener code above, the rest are listed here.     ros::Publisher chatter_pub = n.advertise pb_msgs::Chatter (\"chatter\", 1000);  --   auto talker = talker_node- CreateWriter Chatter (\"channel/chatter\");    chatter_pub.publish(msg);  --   talker- Write(msg);", 
            "title": "Talker"
        }, 
        {
            "location": "/CyberRT_Migration_Guide/#tools-mapping", 
            "text": "ROS  Cyber-RT  Note      rosbag  cyber_recorder  data file    scripts/diagnostics.sh  cyber_monitor  channel debug    offline_lidar_visualizer_tool  cyber_visualizer  point cloud visualizer", 
            "title": "Tools mapping"
        }, 
        {
            "location": "/CyberRT_Migration_Guide/#ros-bag-data-migration", 
            "text": "The data file changed from ROS bag to Cyber record in Cyber-RT. Cyber-RT has a data migration tool  rosbag_to_record  for users to easily migrate data files before Apollo 3.0 (ROS) to Cyber-RT like the sample usage below.   rosbag_to_record demo_3.0.bag demo_3.5.record", 
            "title": "ROS bag data migration"
        }, 
        {
            "location": "/CyberRT_Quick_Start/", 
            "text": "How to create and run a new component in Apollo Cyber RT\n\n\nApollo Cyber RT framework is built based on the concept of component. As a basic building block of Apollo Cyber RT framework, each component contains a specific algorithm module which process a set of data inputs and generate a set of outputs.\n\n\nIn order to successfully create and launch a new compoent, there are four essential steps that need to happen:\n\n\n\n\nSet up the component file structure\n\n\nImplement the component class\n\n\nSet up the configuration files\n\n\nLaunch the component\n\n\n\n\nThe example below demonstrates how to create a simple component, then build, run and watch the final output on screen. If you would like to explore more about Apollo Cyber RT, you can find a couple of examples showing how to use different functionalities of the framework under directory \n/apollo/cyber/examples/\n.\n\n\nNote: the example has to be run within apollo docker environment and it's compiled with Bazel.\n\n\nSet up the component file structure\n\n\nPlease create the following files, assumed under the directory of \n/apollo/cyber/examples/common_component_example/\n:\n\n\n\n\nHeader file: common_component_example.h\n\n\nSource file: common_component_example.cc\n\n\nBuild file: BUILD\n\n\nDAG dependency file: common.dag\n\n\nLaunch file: common.launch\n\n\n\n\nImplement the component class\n\n\nImplement component header file\n\n\nTo implement \ncommon_component_example.h\n:\n\n\n\n\nInherit the Component class\n\n\nDefine your own \nInit\n and \nProc\n functions. Proc function needs to specify its input data types\n\n\nRegister your component classes to be global by using\n\nCYBER_REGISTER_COMPONENT\n\n\n\n\n#include \nmemory\n\n#include \ncyber/class_loader/class_loader.h\n\n#include \ncyber/component/component.h\n\n#include \ncyber/examples/proto/examples.pb.h\n\n\nusing apollo::cyber::examples::proto::Driver;\nusing apollo::cyber::Component;\nusing apollo::cyber::ComponentBase;\n\nclass CommonComponentSample : public Component\nDriver, Driver\n {\n public:\n  bool Init() override;\n  bool Proc(const std::shared_ptr\nDriver\n msg0,\n            const std::shared_ptr\nDriver\n msg1) override;\n};\n\nCYBER_REGISTER_COMPONENT(CommonComponentSample)\n\n\n\n\nImplement the source file for the example component\n\n\nFor \ncommon_component_example.cc\n, both \nInit\n and \nProc\n functions need to be implemented.\n\n\n#include \ncyber/examples/common_component_example/common_component_example.h\n\n#include \ncyber/class_loader/class_loader.h\n\n#include \ncyber/component/component.h\n\n\nbool CommonComponentSample::Init() {\n  AINFO \n \nCommontest component init\n;\n  return true;\n}\n\nbool CommonComponentSample::Proc(const std::shared_ptr\nDriver\n msg0,\n                               const std::shared_ptr\nDriver\n msg1) {\n  AINFO \n \nStart common component Proc [\n \n msg0-\nmsg_id() \n \n] [\n\n        \n msg1-\nmsg_id() \n \n]\n;\n  return true;\n}\n\n\n\n\nCreate the build file for the example component\n\n\nCreate bazel BUILD file.\n\n\nload(\n//tools:cpplint.bzl\n, \ncpplint\n)\n\npackage(default_visibility = [\n//visibility:public\n])\n\ncc_binary(\n    name = \nlibcommon_component_example.so\n,\n    deps = [\n:common_component_example_lib\n],\n    linkopts = [\n-shared\n],\n    linkstatic = False,\n)\n\ncc_library(\n    name = \ncommon_component_example_lib\n,\n    srcs = [\n        \ncommon_component_example.cc\n,\n    ],\n    hdrs = [\n        \ncommon_component_example.h\n,\n    ],\n    deps = [\n        \n//cyber\n,\n        \n//cyber/examples/proto:examples_cc_proto\n,\n    ],\n)\n\ncpplint()\n\n\n\n\nSet up the configuration files\n\n\nConfigure the DAG dependency file\n\n\nTo configure the DAG dependency file (common.dag), specify the following items as below:\n\n\n\n\nChannel names: for data input and output\n\n\nLibrary path: library built from component class\n\n\nClass name: the class name of the component\n\n\n\n\n# Define all coms in DAG streaming.\n    component_config {\n    component_library : \n/apollo/bazel-bin/cyber/examples/common_component_example/libcommon_component_example.so\n\n    components {\n        class_name : \nCommonComponentSample\n\n        config {\n            name : \ncommon\n\n            readers {\n                channel: \n/apollo/prediction\n\n            }\n            readers {\n                channel: \n/apollo/test\n\n            }\n        }\n      }\n    }\n\n\n\n\nConfigure the launch file\n\n\nTo configure the launch (common.launch) file, specify the following items:\n\n\n\n\nThe name of the component\n\n\nThe dag file you just created in the previous step.\n\n\nThe name of the process which the component runs within\n\n\n\n\ncyber\n\n    \ncomponent\n\n        \nname\ncommon\n/name\n\n        \ndag_conf\n/apollo/cyber/examples/common_component_example/common.dag\n/dag_conf\n\n        \nprocess_name\ncommon\n/process_name\n\n    \n/component\n\n\n/cyber\n\n\n\n\n\nLaunch the component\n\n\nBuild the component by running the command below:\n\n\nbash /apollo/apollo.sh build\n\n\n\n\nNote: make sure the example component builds fine\n\n\nThen configure the environment:\n\n\ncd /apollo/cyber\nsource setup.bash\n\n\n\n\nThere are two ways to launch the component:\n\n\n\n\nLaunch with the launch file (recommended)\n\n\n\n\ncyber_launch start /apollo/cyber/examples/common_component_example/common.launch\n\n\n\n\n\n\nLaunch with the DAG file\n\n\n\n\nmainboard -d /apollo/cyber/examples/common_component_example/common.dag", 
            "title": "How to create and run a new component in Apollo Cyber RT"
        }, 
        {
            "location": "/CyberRT_Quick_Start/#how-to-create-and-run-a-new-component-in-apollo-cyber-rt", 
            "text": "Apollo Cyber RT framework is built based on the concept of component. As a basic building block of Apollo Cyber RT framework, each component contains a specific algorithm module which process a set of data inputs and generate a set of outputs.  In order to successfully create and launch a new compoent, there are four essential steps that need to happen:   Set up the component file structure  Implement the component class  Set up the configuration files  Launch the component   The example below demonstrates how to create a simple component, then build, run and watch the final output on screen. If you would like to explore more about Apollo Cyber RT, you can find a couple of examples showing how to use different functionalities of the framework under directory  /apollo/cyber/examples/ .  Note: the example has to be run within apollo docker environment and it's compiled with Bazel.", 
            "title": "How to create and run a new component in Apollo Cyber RT"
        }, 
        {
            "location": "/CyberRT_Quick_Start/#set-up-the-component-file-structure", 
            "text": "Please create the following files, assumed under the directory of  /apollo/cyber/examples/common_component_example/ :   Header file: common_component_example.h  Source file: common_component_example.cc  Build file: BUILD  DAG dependency file: common.dag  Launch file: common.launch", 
            "title": "Set up the component file structure"
        }, 
        {
            "location": "/CyberRT_Quick_Start/#implement-the-component-class", 
            "text": "", 
            "title": "Implement the component class"
        }, 
        {
            "location": "/CyberRT_Quick_Start/#implement-component-header-file", 
            "text": "To implement  common_component_example.h :   Inherit the Component class  Define your own  Init  and  Proc  functions. Proc function needs to specify its input data types  Register your component classes to be global by using CYBER_REGISTER_COMPONENT   #include  memory \n#include  cyber/class_loader/class_loader.h \n#include  cyber/component/component.h \n#include  cyber/examples/proto/examples.pb.h \n\nusing apollo::cyber::examples::proto::Driver;\nusing apollo::cyber::Component;\nusing apollo::cyber::ComponentBase;\n\nclass CommonComponentSample : public Component Driver, Driver  {\n public:\n  bool Init() override;\n  bool Proc(const std::shared_ptr Driver  msg0,\n            const std::shared_ptr Driver  msg1) override;\n};\n\nCYBER_REGISTER_COMPONENT(CommonComponentSample)", 
            "title": "Implement component header file"
        }, 
        {
            "location": "/CyberRT_Quick_Start/#implement-the-source-file-for-the-example-component", 
            "text": "For  common_component_example.cc , both  Init  and  Proc  functions need to be implemented.  #include  cyber/examples/common_component_example/common_component_example.h \n#include  cyber/class_loader/class_loader.h \n#include  cyber/component/component.h \n\nbool CommonComponentSample::Init() {\n  AINFO    Commontest component init ;\n  return true;\n}\n\nbool CommonComponentSample::Proc(const std::shared_ptr Driver  msg0,\n                               const std::shared_ptr Driver  msg1) {\n  AINFO    Start common component Proc [    msg0- msg_id()    ] [ \n          msg1- msg_id()    ] ;\n  return true;\n}", 
            "title": "Implement the source file for the example component"
        }, 
        {
            "location": "/CyberRT_Quick_Start/#create-the-build-file-for-the-example-component", 
            "text": "Create bazel BUILD file.  load( //tools:cpplint.bzl ,  cpplint )\n\npackage(default_visibility = [ //visibility:public ])\n\ncc_binary(\n    name =  libcommon_component_example.so ,\n    deps = [ :common_component_example_lib ],\n    linkopts = [ -shared ],\n    linkstatic = False,\n)\n\ncc_library(\n    name =  common_component_example_lib ,\n    srcs = [\n         common_component_example.cc ,\n    ],\n    hdrs = [\n         common_component_example.h ,\n    ],\n    deps = [\n         //cyber ,\n         //cyber/examples/proto:examples_cc_proto ,\n    ],\n)\n\ncpplint()", 
            "title": "Create the build file for the example component"
        }, 
        {
            "location": "/CyberRT_Quick_Start/#set-up-the-configuration-files", 
            "text": "", 
            "title": "Set up the configuration files"
        }, 
        {
            "location": "/CyberRT_Quick_Start/#configure-the-dag-dependency-file", 
            "text": "To configure the DAG dependency file (common.dag), specify the following items as below:   Channel names: for data input and output  Library path: library built from component class  Class name: the class name of the component   # Define all coms in DAG streaming.\n    component_config {\n    component_library :  /apollo/bazel-bin/cyber/examples/common_component_example/libcommon_component_example.so \n    components {\n        class_name :  CommonComponentSample \n        config {\n            name :  common \n            readers {\n                channel:  /apollo/prediction \n            }\n            readers {\n                channel:  /apollo/test \n            }\n        }\n      }\n    }", 
            "title": "Configure the DAG dependency file"
        }, 
        {
            "location": "/CyberRT_Quick_Start/#configure-the-launch-file", 
            "text": "To configure the launch (common.launch) file, specify the following items:   The name of the component  The dag file you just created in the previous step.  The name of the process which the component runs within   cyber \n     component \n         name common /name \n         dag_conf /apollo/cyber/examples/common_component_example/common.dag /dag_conf \n         process_name common /process_name \n     /component  /cyber", 
            "title": "Configure the launch file"
        }, 
        {
            "location": "/CyberRT_Quick_Start/#launch-the-component", 
            "text": "Build the component by running the command below:  bash /apollo/apollo.sh build  Note: make sure the example component builds fine  Then configure the environment:  cd /apollo/cyber\nsource setup.bash  There are two ways to launch the component:   Launch with the launch file (recommended)   cyber_launch start /apollo/cyber/examples/common_component_example/common.launch   Launch with the DAG file   mainboard -d /apollo/cyber/examples/common_component_example/common.dag", 
            "title": "Launch the component"
        }, 
        {
            "location": "/CyberRT_Quick_Start_cn/", 
            "text": "\u5982\u4f55\u4f7f\u7528Cyber RT\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u7ec4\u4ef6\n\n\nApollo Cyber \u8fd0\u884c\u65f6\u6846\u67b6(Apollo Cyber RT Framework) \u662f\u57fa\u4e8e\u7ec4\u4ef6\u6982\u5ff5\u6765\u6784\u5efa\u7684. \u6bcf\u4e2a\u7ec4\u4ef6\u90fd\u662fCyber\u6846\u67b6\u7684\u4e00\u4e2a\u6784\u5efa\u5757, \u5b83\u5305\u62ec\u4e00\u4e2a\u7279\u5b9a\u7684\u7b97\u6cd5\u6a21\u5757\uff0c \u6b64\u7b97\u6cd5\u6a21\u5757\u5904\u7406\u4e00\u7ec4\u8f93\u5165\u6570\u6910\u5e76\u4ea7\u751f\u4e00\u7ec4\u8f93\u51fa\u6570\u6910\u3002\n\n\n\u8981\u521b\u5efa\u5e76\u542f\u52a8\u4e00\u4e2a\u7b97\u6cd5\u7ec4\u4ef6, \u9700\u8981\u901a\u8fc7\u4ee5\u4e0b4\u4e2a\u6b65\u9aa4:\n\n\n\n\n\u521d\u5982\u5316\u7ec4\u4ef6\u7684\u6587\u4ef6\u7ed3\u6784\n\n\n\u5b9e\u73b0\u7ec4\u4ef6\u7c7b\n\n\n\u8bbe\u7f6e\u914d\u7f6e\u6587\u4ef6 \n\n\n\u542f\u52a8\u7ec4\u4ef6\n\n\n\n\n\u4e0b\u9762\u7684\u4f8b\u5b50\u5c55\u793a\u4e86\u5982\u4f55\u521b\u5efa\uff0c\u7f16\u8bd1\uff0c\u8fd0\u884c\u4e00\u4e2a\u7ec4\u4ef6\uff0c\u5e76\u89c2\u5bdf\u7ec4\u4ef6\u5728\u5c4f\u5e55\u4e0a\u7684\u8f93\u51fa\u3002 \u5982\u679c\u60f3\u66f4\u6df1\u5165\u7684\u63a2\u7d22Apollo Cyber RT\u6846\u67b6, \u53ef\u4ee5\u5728\u8fd9\u4e2a\u76ee\u5f55\n/apollo/cyber/examples/\n\u627e\u5230\u5f88\u591a\u4f8b\u5b50\uff0c\u8fd9\u4e9b\u4f8b\u5b50\u8be6\u7ec6\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528Cyber\u6846\u67b6\u7684\u5404\u79cd\u529f\u80fd\u3002\n\n\nNote: \u8fd9\u4e9b\u4f8b\u5b50\u5fc5\u987b\u8fd0\u884c\u5728Apollo docker\u73af\u5883\uff0c \u4e14\u9700\u8981\u901a\u8fc7Bazel\u6765\u7f16\u8bd1.\n\n\n\u521d\u59cb\u5316\u7ec4\u4ef6\u6587\u4ef6\u7ed3\u6784\n\n\n\u4f8b\u5982\u7ec4\u4ef6\u7684\u6839\u76ee\u5f55\u4e3a\n/apollo/cyber/examples/common_component_example/\n\u9700\u8981\u521b\u5efa\u4ee5\u4e0b\u6587\u4ef6:\n\n\n\n\nHeader file: common_component_example.h\n\n\nSource file: common_component_example.cc\n\n\nBuild file: BUILD\n\n\nDAG dependency file: common.dag\n\n\nLaunch file: common.launch\n\n\n\n\n\u5b9e\u73b0\u7ec4\u4ef6\u7c7b\n\n\n\u5b9e\u73b0\u7ec4\u4ef6\u5934\u6587\u4ef6\n\n\n\u5982\u4f55\u5b9e\u73b0\ncommon_component_example.h\n:\n\n\n\n\n\u7ee7\u627f Component \u7c7b\n\n\n\u5b9a\u4e49\u81ea\u5df1\u7684 \nInit\n \u548c \nProc\n \u51fd\u6570. Proc \u9700\u8981\u6307\u5b9a\u8f93\u5165\u6570\u6910\u7c7b\u578b\u3002\n\n\n\u4f7f\u7528\nCYBER_REGISTER_COMPONENT\n\u5b8f\u5b9a\u4e49\u628a\u7ec4\u4ef6\u7c7b\u6ce8\u518c\u6210\u5168\u5c40\u53ef\u7528\u3002\n\n\n\n\n#include \nmemory\n\n#include \ncyber/class_loader/class_loader.h\n\n#include \ncyber/component/component.h\n\n#include \ncyber/examples/proto/examples.pb.h\n\n\nusing apollo::cyber::examples::proto::Driver;\nusing apollo::cyber::Component;\nusing apollo::cyber::ComponentBase;\n\nclass CommonComponentSample : public Component\nDriver, Driver\n {\n public:\n  bool Init() override;\n  bool Proc(const std::shared_ptr\nDriver\n msg0,\n            const std::shared_ptr\nDriver\n msg1) override;\n};\n\nCYBER_REGISTER_COMPONENT(CommonComponentSample)\n\n\n\n\n\u5b9e\u73b0\u7ec4\u4ef6\u6e90\u6587\u4ef6\n\n\n\u5bf9\u4e8e\u6e90\u6587\u4ef6 \ncommon_component_example.cc\n,  \nInit\n \u548c \nProc\n \u8fd9\u4e24\u4e2a\u51fd\u6570\u9700\u8981\u5b9e\u73b0.\n\n\n#include \ncyber/examples/common_component_example/common_component_example.h\n\n#include \ncyber/class_loader/class_loader.h\n\n#include \ncyber/component/component.h\n\n\nbool CommonComponentSample::Init() {\n  AINFO \n \nCommontest component init\n;\n  return true;\n}\n\nbool CommonComponentSample::Proc(const std::shared_ptr\nDriver\n msg0,\n                               const std::shared_ptr\nDriver\n msg1) {\n  AINFO \n \nStart common component Proc [\n \n msg0-\nmsg_id() \n \n] [\n\n        \n msg1-\nmsg_id() \n \n]\n;\n  return true;\n}\n\n\n\n\n\u521b\u5efaBUILD\u7f16\u8bd1\u6587\u4ef6\n\n\n\u521b\u5efa bazel BUILD \u6587\u4ef6.\n\n\nload(\n//tools:cpplint.bzl\n, \ncpplint\n)\n\npackage(default_visibility = [\n//visibility:public\n])\n\ncc_binary(\n    name = \nlibcommon_component_example.so\n,\n    deps = [\n:common_component_example_lib\n],\n    linkopts = [\n-shared\n],\n    linkstatic = False,\n)\n\ncc_library(\n    name = \ncommon_component_example_lib\n,\n    srcs = [\n        \ncommon_component_example.cc\n,\n    ],\n    hdrs = [\n        \ncommon_component_example.h\n,\n    ],\n    deps = [\n        \n//cyber\n,\n        \n//cyber/examples/proto:examples_cc_proto\n,\n    ],\n)\n\ncpplint()\n\n\n\n\n\u8bbe\u7f6e\u914d\u7f6e\u6587\u4ef6\n\n\n\u914d\u7f6eDAG\u4f9d\u8d56\u6587\u4ef6\n\n\n\u5728DAG\u4f9d\u8d56\u914d\u7f6e\u6587\u4ef6 (\u4f8b\u5982common.dag)\u4e2d\u914d\u7f6e\u4e0b\u9762\u7684\u9879:\n\n\n\n\nChannel names: \u8f93\u5165\u8f93\u51fa\u6570\u6910\u7684Channel\u540d\u5b57\n\n\nLibrary path: \u6b64\u7ec4\u4ef6\u6700\u7ec8\u7f16\u8bd1\u51fa\u7684\u5e93\u7684\u540d\u5b57\n\n\nClass name: \u6b64\u7ec4\u4ef6\u7684\u5165\u53e3\u7c7b\u7684\u540d\u5b57\n\n\n\n\n# Define all coms in DAG streaming.\n    component_config {\n    component_library : \n/apollo/bazel-bin/cyber/examples/common_component_example/libcommon_component_example.so\n\n    components {\n        class_name : \nCommonComponentSample\n\n        config {\n            name : \ncommon\n\n            readers {\n                channel: \n/apollo/prediction\n\n            }\n            readers {\n                channel: \n/apollo/test\n\n            }\n        }\n      }\n    }\n\n\n\n\n\u914d\u7f6elaunch\u542f\u52a8\u6587\u4ef6\n\n\n\u5728launch\u542f\u52a8\u6587\u4ef6\u4e2d(common.launch), \u914d\u7f6e\u4e0b\u9762\u7684\u9879:\n\n\n\n\n\u7ec4\u4ef6\u7684\u540d\u5b57\n\n\n\u4e0a\u4e00\u6b65\u521b\u5efa\u7684dag\u914d\u7f6e\u7684\u540d\u5b57\u3002\n\n\n\u7ec4\u4ef6\u8fd0\u884c\u65f6\u6240\u5728\u7684\u8fdb\u7a0b\u76ee\u5f55\u3002\n\n\n\n\ncyber\n\n    \ncomponent\n\n        \nname\ncommon\n/name\n\n        \ndag_conf\n/apollo/cyber/examples/common_component_example/common.dag\n/dag_conf\n\n        \nprocess_name\ncommon\n/process_name\n\n    \n/component\n\n\n/cyber\n\n\n\n\n\n\u542f\u52a8\u8fd9\u4e2a\u7ec4\u4ef6\n\n\n\u901a\u8fc7\u4e0b\u9762\u7684\u547d\u4ee4\u6765\u7f16\u8bd1\u7ec4\u4ef6:\n\n\nbash /apollo/apollo.sh build\n\n\n\n\nNote: \u786e\u5b9a\u7ec4\u4ef6\u6b63\u5e38\u7f16\u8bd1\u6210\u529f\n\n\n\u7136\u540e\u914d\u7f6e\u73af\u5883:\n\n\ncd /apollo/cyber\nsource setup.bash\n\n\n\n\n\u6709\u4e24\u79cd\u65b9\u6cd5\u6765\u542f\u52a8\u7ec4\u4ef6:\n\n\n\n\n\u4f7f\u7528launch\u6587\u4ef6\u6765\u542f\u52a8 (\u63a8\u8350\u8fd9\u79cd\u65b9\u5f0f)\n\n\n\n\ncyber_launch start /apollo/cyber/examples/common_component_example/common.launch\n\n\n\n\n\n\n\u4f7f\u7528dag\u6587\u4ef6\u6765\u542f\u52a8\n\n\n\n\nmainboard -d /apollo/cyber/examples/common_component_example/common.dag", 
            "title": "\u5982\u4f55\u4f7f\u7528Cyber RT\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u7ec4\u4ef6"
        }, 
        {
            "location": "/CyberRT_Quick_Start_cn/#cyber-rt", 
            "text": "Apollo Cyber \u8fd0\u884c\u65f6\u6846\u67b6(Apollo Cyber RT Framework) \u662f\u57fa\u4e8e\u7ec4\u4ef6\u6982\u5ff5\u6765\u6784\u5efa\u7684. \u6bcf\u4e2a\u7ec4\u4ef6\u90fd\u662fCyber\u6846\u67b6\u7684\u4e00\u4e2a\u6784\u5efa\u5757, \u5b83\u5305\u62ec\u4e00\u4e2a\u7279\u5b9a\u7684\u7b97\u6cd5\u6a21\u5757\uff0c \u6b64\u7b97\u6cd5\u6a21\u5757\u5904\u7406\u4e00\u7ec4\u8f93\u5165\u6570\u6910\u5e76\u4ea7\u751f\u4e00\u7ec4\u8f93\u51fa\u6570\u6910\u3002  \u8981\u521b\u5efa\u5e76\u542f\u52a8\u4e00\u4e2a\u7b97\u6cd5\u7ec4\u4ef6, \u9700\u8981\u901a\u8fc7\u4ee5\u4e0b4\u4e2a\u6b65\u9aa4:   \u521d\u5982\u5316\u7ec4\u4ef6\u7684\u6587\u4ef6\u7ed3\u6784  \u5b9e\u73b0\u7ec4\u4ef6\u7c7b  \u8bbe\u7f6e\u914d\u7f6e\u6587\u4ef6   \u542f\u52a8\u7ec4\u4ef6   \u4e0b\u9762\u7684\u4f8b\u5b50\u5c55\u793a\u4e86\u5982\u4f55\u521b\u5efa\uff0c\u7f16\u8bd1\uff0c\u8fd0\u884c\u4e00\u4e2a\u7ec4\u4ef6\uff0c\u5e76\u89c2\u5bdf\u7ec4\u4ef6\u5728\u5c4f\u5e55\u4e0a\u7684\u8f93\u51fa\u3002 \u5982\u679c\u60f3\u66f4\u6df1\u5165\u7684\u63a2\u7d22Apollo Cyber RT\u6846\u67b6, \u53ef\u4ee5\u5728\u8fd9\u4e2a\u76ee\u5f55 /apollo/cyber/examples/ \u627e\u5230\u5f88\u591a\u4f8b\u5b50\uff0c\u8fd9\u4e9b\u4f8b\u5b50\u8be6\u7ec6\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528Cyber\u6846\u67b6\u7684\u5404\u79cd\u529f\u80fd\u3002  Note: \u8fd9\u4e9b\u4f8b\u5b50\u5fc5\u987b\u8fd0\u884c\u5728Apollo docker\u73af\u5883\uff0c \u4e14\u9700\u8981\u901a\u8fc7Bazel\u6765\u7f16\u8bd1.", 
            "title": "\u5982\u4f55\u4f7f\u7528Cyber RT\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u7ec4\u4ef6"
        }, 
        {
            "location": "/CyberRT_Quick_Start_cn/#_1", 
            "text": "\u4f8b\u5982\u7ec4\u4ef6\u7684\u6839\u76ee\u5f55\u4e3a /apollo/cyber/examples/common_component_example/ \u9700\u8981\u521b\u5efa\u4ee5\u4e0b\u6587\u4ef6:   Header file: common_component_example.h  Source file: common_component_example.cc  Build file: BUILD  DAG dependency file: common.dag  Launch file: common.launch", 
            "title": "\u521d\u59cb\u5316\u7ec4\u4ef6\u6587\u4ef6\u7ed3\u6784"
        }, 
        {
            "location": "/CyberRT_Quick_Start_cn/#_2", 
            "text": "", 
            "title": "\u5b9e\u73b0\u7ec4\u4ef6\u7c7b"
        }, 
        {
            "location": "/CyberRT_Quick_Start_cn/#_3", 
            "text": "\u5982\u4f55\u5b9e\u73b0 common_component_example.h :   \u7ee7\u627f Component \u7c7b  \u5b9a\u4e49\u81ea\u5df1\u7684  Init  \u548c  Proc  \u51fd\u6570. Proc \u9700\u8981\u6307\u5b9a\u8f93\u5165\u6570\u6910\u7c7b\u578b\u3002  \u4f7f\u7528 CYBER_REGISTER_COMPONENT \u5b8f\u5b9a\u4e49\u628a\u7ec4\u4ef6\u7c7b\u6ce8\u518c\u6210\u5168\u5c40\u53ef\u7528\u3002   #include  memory \n#include  cyber/class_loader/class_loader.h \n#include  cyber/component/component.h \n#include  cyber/examples/proto/examples.pb.h \n\nusing apollo::cyber::examples::proto::Driver;\nusing apollo::cyber::Component;\nusing apollo::cyber::ComponentBase;\n\nclass CommonComponentSample : public Component Driver, Driver  {\n public:\n  bool Init() override;\n  bool Proc(const std::shared_ptr Driver  msg0,\n            const std::shared_ptr Driver  msg1) override;\n};\n\nCYBER_REGISTER_COMPONENT(CommonComponentSample)", 
            "title": "\u5b9e\u73b0\u7ec4\u4ef6\u5934\u6587\u4ef6"
        }, 
        {
            "location": "/CyberRT_Quick_Start_cn/#_4", 
            "text": "\u5bf9\u4e8e\u6e90\u6587\u4ef6  common_component_example.cc ,   Init  \u548c  Proc  \u8fd9\u4e24\u4e2a\u51fd\u6570\u9700\u8981\u5b9e\u73b0.  #include  cyber/examples/common_component_example/common_component_example.h \n#include  cyber/class_loader/class_loader.h \n#include  cyber/component/component.h \n\nbool CommonComponentSample::Init() {\n  AINFO    Commontest component init ;\n  return true;\n}\n\nbool CommonComponentSample::Proc(const std::shared_ptr Driver  msg0,\n                               const std::shared_ptr Driver  msg1) {\n  AINFO    Start common component Proc [    msg0- msg_id()    ] [ \n          msg1- msg_id()    ] ;\n  return true;\n}", 
            "title": "\u5b9e\u73b0\u7ec4\u4ef6\u6e90\u6587\u4ef6"
        }, 
        {
            "location": "/CyberRT_Quick_Start_cn/#build", 
            "text": "\u521b\u5efa bazel BUILD \u6587\u4ef6.  load( //tools:cpplint.bzl ,  cpplint )\n\npackage(default_visibility = [ //visibility:public ])\n\ncc_binary(\n    name =  libcommon_component_example.so ,\n    deps = [ :common_component_example_lib ],\n    linkopts = [ -shared ],\n    linkstatic = False,\n)\n\ncc_library(\n    name =  common_component_example_lib ,\n    srcs = [\n         common_component_example.cc ,\n    ],\n    hdrs = [\n         common_component_example.h ,\n    ],\n    deps = [\n         //cyber ,\n         //cyber/examples/proto:examples_cc_proto ,\n    ],\n)\n\ncpplint()", 
            "title": "\u521b\u5efaBUILD\u7f16\u8bd1\u6587\u4ef6"
        }, 
        {
            "location": "/CyberRT_Quick_Start_cn/#_5", 
            "text": "", 
            "title": "\u8bbe\u7f6e\u914d\u7f6e\u6587\u4ef6"
        }, 
        {
            "location": "/CyberRT_Quick_Start_cn/#dag", 
            "text": "\u5728DAG\u4f9d\u8d56\u914d\u7f6e\u6587\u4ef6 (\u4f8b\u5982common.dag)\u4e2d\u914d\u7f6e\u4e0b\u9762\u7684\u9879:   Channel names: \u8f93\u5165\u8f93\u51fa\u6570\u6910\u7684Channel\u540d\u5b57  Library path: \u6b64\u7ec4\u4ef6\u6700\u7ec8\u7f16\u8bd1\u51fa\u7684\u5e93\u7684\u540d\u5b57  Class name: \u6b64\u7ec4\u4ef6\u7684\u5165\u53e3\u7c7b\u7684\u540d\u5b57   # Define all coms in DAG streaming.\n    component_config {\n    component_library :  /apollo/bazel-bin/cyber/examples/common_component_example/libcommon_component_example.so \n    components {\n        class_name :  CommonComponentSample \n        config {\n            name :  common \n            readers {\n                channel:  /apollo/prediction \n            }\n            readers {\n                channel:  /apollo/test \n            }\n        }\n      }\n    }", 
            "title": "\u914d\u7f6eDAG\u4f9d\u8d56\u6587\u4ef6"
        }, 
        {
            "location": "/CyberRT_Quick_Start_cn/#launch", 
            "text": "\u5728launch\u542f\u52a8\u6587\u4ef6\u4e2d(common.launch), \u914d\u7f6e\u4e0b\u9762\u7684\u9879:   \u7ec4\u4ef6\u7684\u540d\u5b57  \u4e0a\u4e00\u6b65\u521b\u5efa\u7684dag\u914d\u7f6e\u7684\u540d\u5b57\u3002  \u7ec4\u4ef6\u8fd0\u884c\u65f6\u6240\u5728\u7684\u8fdb\u7a0b\u76ee\u5f55\u3002   cyber \n     component \n         name common /name \n         dag_conf /apollo/cyber/examples/common_component_example/common.dag /dag_conf \n         process_name common /process_name \n     /component  /cyber", 
            "title": "\u914d\u7f6elaunch\u542f\u52a8\u6587\u4ef6"
        }, 
        {
            "location": "/CyberRT_Quick_Start_cn/#_6", 
            "text": "\u901a\u8fc7\u4e0b\u9762\u7684\u547d\u4ee4\u6765\u7f16\u8bd1\u7ec4\u4ef6:  bash /apollo/apollo.sh build  Note: \u786e\u5b9a\u7ec4\u4ef6\u6b63\u5e38\u7f16\u8bd1\u6210\u529f  \u7136\u540e\u914d\u7f6e\u73af\u5883:  cd /apollo/cyber\nsource setup.bash  \u6709\u4e24\u79cd\u65b9\u6cd5\u6765\u542f\u52a8\u7ec4\u4ef6:   \u4f7f\u7528launch\u6587\u4ef6\u6765\u542f\u52a8 (\u63a8\u8350\u8fd9\u79cd\u65b9\u5f0f)   cyber_launch start /apollo/cyber/examples/common_component_example/common.launch   \u4f7f\u7528dag\u6587\u4ef6\u6765\u542f\u52a8   mainboard -d /apollo/cyber/examples/common_component_example/common.dag", 
            "title": "\u542f\u52a8\u8fd9\u4e2a\u7ec4\u4ef6"
        }, 
        {
            "location": "/CyberRT_Terms/", 
            "text": "Apollo Cyber RT Terminologies\n\n\nThis page describes the definitions of the most commonly used terminologies in Cyber RT.\n\n\nComponent\n\n\nIn an autonomous driving system, modules(like perception, localization, control systems...) exist in the form of components under Cyber RT. Each component communicates with the others through Cyber channels. The component concept not only decouples modules but also provides the flexibility for modules to be divided into components based individual module design.\n\n\nChannel\n\n\nChannels are used to manage data communication in Cyber RT. Users can publish/subscribe to the same channel to achieve p2p communication.\n\n\nTask\n\n\nTask is the abstract description of an asynchronous computation task in Cyber RT.\n\n\nNode\n\n\nNode is the fundamental building block of Cyber RT; every module contains and communicates through the node. A module can have different types of communication by defining read/write and/or service/client in a node. \n\n\nReader/Writer\n\n\nMessage read/write class from/to channel. Reader/Writer are normally created within a node as the major message transfer interface in Cyber RT.\n\n\nService/Client\n\n\nBesides Reader/writer, Cyber RT also provides service/client pattern for module communication. It supports two-way communication between nodes. A client node will receive a response when a request is made to a service.\n\n\nParameter\n\n\nParameter service provides a global parameter access interface in Cyber RT. It's built based on the service/client pattern.\n\n\nService discovery\n\n\nAs a decentralized design framework, Cyber RT does not have a master/central node for service registration. All nodes are treated equally and can find other service nodes through \nservice discovery\n. \nUDP\n is used in Service discovery.\n\n\nCRoutine\n\n\nReferred to as Coroutine concept, Cyber RT implemented CRoutine to optimize thread usage and system reource allocation.\n\n\nScheduler\n\n\nTo better support autonomous driving scenarios, Cyber RT provides different kinds of resource scheduling algorithms for developers to choose from.\n\n\nMessage\n\n\nMessage is the data unit used in Cyber RT for data transfer between modules.\n\n\nDag file\n\n\nDag file is the config file of module topology. You can define components used and upstream/downstream channels in the dag file.\n\n\nLaunch files\n\n\nThe Launch file provides a easy way to start modules. By defining one or multiple dag files in the launch file, you can start multiple modules at the same time.\n\n\nRecord file\n\n\nThe Record file is used to record messages sent/received to/from channels in Cyber RT. Reply record files can help reproduce the behavior of previous operations of Cyber RT.", 
            "title": "Apollo Cyber RT Terminologies"
        }, 
        {
            "location": "/CyberRT_Terms/#apollo-cyber-rt-terminologies", 
            "text": "This page describes the definitions of the most commonly used terminologies in Cyber RT.", 
            "title": "Apollo Cyber RT Terminologies"
        }, 
        {
            "location": "/CyberRT_Terms/#component", 
            "text": "In an autonomous driving system, modules(like perception, localization, control systems...) exist in the form of components under Cyber RT. Each component communicates with the others through Cyber channels. The component concept not only decouples modules but also provides the flexibility for modules to be divided into components based individual module design.", 
            "title": "Component"
        }, 
        {
            "location": "/CyberRT_Terms/#channel", 
            "text": "Channels are used to manage data communication in Cyber RT. Users can publish/subscribe to the same channel to achieve p2p communication.", 
            "title": "Channel"
        }, 
        {
            "location": "/CyberRT_Terms/#task", 
            "text": "Task is the abstract description of an asynchronous computation task in Cyber RT.", 
            "title": "Task"
        }, 
        {
            "location": "/CyberRT_Terms/#node", 
            "text": "Node is the fundamental building block of Cyber RT; every module contains and communicates through the node. A module can have different types of communication by defining read/write and/or service/client in a node.", 
            "title": "Node"
        }, 
        {
            "location": "/CyberRT_Terms/#readerwriter", 
            "text": "Message read/write class from/to channel. Reader/Writer are normally created within a node as the major message transfer interface in Cyber RT.", 
            "title": "Reader/Writer"
        }, 
        {
            "location": "/CyberRT_Terms/#serviceclient", 
            "text": "Besides Reader/writer, Cyber RT also provides service/client pattern for module communication. It supports two-way communication between nodes. A client node will receive a response when a request is made to a service.", 
            "title": "Service/Client"
        }, 
        {
            "location": "/CyberRT_Terms/#parameter", 
            "text": "Parameter service provides a global parameter access interface in Cyber RT. It's built based on the service/client pattern.", 
            "title": "Parameter"
        }, 
        {
            "location": "/CyberRT_Terms/#service-discovery", 
            "text": "As a decentralized design framework, Cyber RT does not have a master/central node for service registration. All nodes are treated equally and can find other service nodes through  service discovery .  UDP  is used in Service discovery.", 
            "title": "Service discovery"
        }, 
        {
            "location": "/CyberRT_Terms/#croutine", 
            "text": "Referred to as Coroutine concept, Cyber RT implemented CRoutine to optimize thread usage and system reource allocation.", 
            "title": "CRoutine"
        }, 
        {
            "location": "/CyberRT_Terms/#scheduler", 
            "text": "To better support autonomous driving scenarios, Cyber RT provides different kinds of resource scheduling algorithms for developers to choose from.", 
            "title": "Scheduler"
        }, 
        {
            "location": "/CyberRT_Terms/#message", 
            "text": "Message is the data unit used in Cyber RT for data transfer between modules.", 
            "title": "Message"
        }, 
        {
            "location": "/CyberRT_Terms/#dag-file", 
            "text": "Dag file is the config file of module topology. You can define components used and upstream/downstream channels in the dag file.", 
            "title": "Dag file"
        }, 
        {
            "location": "/CyberRT_Terms/#launch-files", 
            "text": "The Launch file provides a easy way to start modules. By defining one or multiple dag files in the launch file, you can start multiple modules at the same time.", 
            "title": "Launch files"
        }, 
        {
            "location": "/CyberRT_Terms/#record-file", 
            "text": "The Record file is used to record messages sent/received to/from channels in Cyber RT. Reply record files can help reproduce the behavior of previous operations of Cyber RT.", 
            "title": "Record file"
        }, 
        {
            "location": "/README/", 
            "text": "Apollo Cyber RT\n\n\n\n\n\n\nApollo Cyber RT Quick Start9\n: Everything you need to know about how to start developing your first application module on top of Apollo Cyber RT. \n\n\n\n\n\n\nApollo Cyber RT Developer Tools\n: Detailed guidance on how to use the developer tools from Apollo Cyber RT. \n\n\n\n\n\n\nApollo Cyber RT API for Developers\n: A comprehensive guide to explore all the APIs of Apollo Cyber RT, with many concrete examples in source code.\n\n\n\n\n\n\nApollo Cyber RT FAQs\n: Answers to the most frequently asked questions about Apollo Cyber RT.\n\n\n\n\n\n\nApollo Cyber RT Terms\n: Commonly used terminologies in Cyber RT documentation and code.\n\n\n\n\n\n\nMore documents to come soon!", 
            "title": "Apollo Cyber RT"
        }, 
        {
            "location": "/README/#apollo-cyber-rt", 
            "text": "Apollo Cyber RT Quick Start9 : Everything you need to know about how to start developing your first application module on top of Apollo Cyber RT.     Apollo Cyber RT Developer Tools : Detailed guidance on how to use the developer tools from Apollo Cyber RT.     Apollo Cyber RT API for Developers : A comprehensive guide to explore all the APIs of Apollo Cyber RT, with many concrete examples in source code.    Apollo Cyber RT FAQs : Answers to the most frequently asked questions about Apollo Cyber RT.    Apollo Cyber RT Terms : Commonly used terminologies in Cyber RT documentation and code.    More documents to come soon!", 
            "title": "Apollo Cyber RT"
        }
    ]
}